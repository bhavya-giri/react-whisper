/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_react-audio-voice-recorder_dist_index-1c988149_js"],{

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxxQ0FBcUMscUJBQU0saUZBQWlGLHFCQUFNLGtFQUFrRSxxQkFBTSxXQUFXLG1CQUFPLENBQUMsd0ZBQTRCOztBQUV6UCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzP2NhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2dsb2JhbF9wcm9jZXNzLCBfZ2xvYmFsX3Byb2Nlc3MxO1xubW9kdWxlLmV4cG9ydHMgPSAoKF9nbG9iYWxfcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbF9wcm9jZXNzLmVudikgJiYgdHlwZW9mICgoX2dsb2JhbF9wcm9jZXNzMSA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbF9wcm9jZXNzMS5lbnYpID09PSBcIm9iamVjdFwiID8gZ2xvYmFsLnByb2Nlc3MgOiByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3NcIik7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/MWIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MjI5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDIyOSk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "./node_modules/react-audio-voice-recorder/dist/index-1c988149.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-audio-voice-recorder/dist/index-1c988149.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: function() { return /* binding */ qe; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\nfunction re(o, f) {\n  for (var s = 0; s < f.length; s++) {\n    const p = f[s];\n    if (typeof p != \"string\" && !Array.isArray(p)) {\n      for (const c in p)\n        if (c !== \"default\" && !(c in o)) {\n          const l = Object.getOwnPropertyDescriptor(p, c);\n          l && Object.defineProperty(o, c, l.get ? l : {\n            enumerable: !0,\n            get: () => p[c]\n          });\n        }\n    }\n  }\n  return Object.freeze(Object.defineProperty(o, Symbol.toStringTag, { value: \"Module\" }));\n}\nfunction oe(o) {\n  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, \"default\") ? o.default : o;\n}\nfunction ne(o) {\n  if (o.__esModule)\n    return o;\n  var f = o.default;\n  if (typeof f == \"function\") {\n    var s = function p() {\n      if (this instanceof p) {\n        var c = [null];\n        c.push.apply(c, arguments);\n        var l = Function.bind.apply(f, c);\n        return new l();\n      }\n      return f.apply(this, arguments);\n    };\n    s.prototype = f.prototype;\n  } else\n    s = {};\n  return Object.defineProperty(s, \"__esModule\", { value: !0 }), Object.keys(o).forEach(function(p) {\n    var c = Object.getOwnPropertyDescriptor(o, p);\n    Object.defineProperty(s, p, c.get ? c : {\n      enumerable: !0,\n      get: function() {\n        return o[p];\n      }\n    });\n  }), s;\n}\nvar ie = { exports: {} };\n(function(o) {\n  var f = function(s) {\n    var p = Object.prototype, c = p.hasOwnProperty, l, j = typeof Symbol == \"function\" ? Symbol : {}, y = j.iterator || \"@@iterator\", m = j.asyncIterator || \"@@asyncIterator\", v = j.toStringTag || \"@@toStringTag\";\n    function w(t, e, r) {\n      return Object.defineProperty(t, e, {\n        value: r,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }), t[e];\n    }\n    try {\n      w({}, \"\");\n    } catch {\n      w = function(e, r, i) {\n        return e[r] = i;\n      };\n    }\n    function C(t, e, r, i) {\n      var n = e && e.prototype instanceof O ? e : O, d = Object.create(n.prototype), b = new u(i || []);\n      return d._invoke = V(t, r, b), d;\n    }\n    s.wrap = C;\n    function N(t, e, r) {\n      try {\n        return { type: \"normal\", arg: t.call(e, r) };\n      } catch (i) {\n        return { type: \"throw\", arg: i };\n      }\n    }\n    var _ = \"suspendedStart\", G = \"suspendedYield\", U = \"executing\", P = \"completed\", L = {};\n    function O() {\n    }\n    function T() {\n    }\n    function k() {\n    }\n    var D = {};\n    w(D, y, function() {\n      return this;\n    });\n    var B = Object.getPrototypeOf, M = B && B(B(h([])));\n    M && M !== p && c.call(M, y) && (D = M);\n    var $ = k.prototype = O.prototype = Object.create(D);\n    T.prototype = k, w($, \"constructor\", k), w(k, \"constructor\", T), T.displayName = w(\n      k,\n      v,\n      \"GeneratorFunction\"\n    );\n    function Y(t) {\n      [\"next\", \"throw\", \"return\"].forEach(function(e) {\n        w(t, e, function(r) {\n          return this._invoke(e, r);\n        });\n      });\n    }\n    s.isGeneratorFunction = function(t) {\n      var e = typeof t == \"function\" && t.constructor;\n      return e ? e === T || // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (e.displayName || e.name) === \"GeneratorFunction\" : !1;\n    }, s.mark = function(t) {\n      return Object.setPrototypeOf ? Object.setPrototypeOf(t, k) : (t.__proto__ = k, w(t, v, \"GeneratorFunction\")), t.prototype = Object.create($), t;\n    }, s.awrap = function(t) {\n      return { __await: t };\n    };\n    function I(t, e) {\n      function r(d, b, F, S) {\n        var E = N(t[d], t, b);\n        if (E.type === \"throw\")\n          S(E.arg);\n        else {\n          var H = E.arg, z = H.value;\n          return z && typeof z == \"object\" && c.call(z, \"__await\") ? e.resolve(z.__await).then(function(R) {\n            r(\"next\", R, F, S);\n          }, function(R) {\n            r(\"throw\", R, F, S);\n          }) : e.resolve(z).then(function(R) {\n            H.value = R, F(H);\n          }, function(R) {\n            return r(\"throw\", R, F, S);\n          });\n        }\n      }\n      var i;\n      function n(d, b) {\n        function F() {\n          return new e(function(S, E) {\n            r(d, b, S, E);\n          });\n        }\n        return i = // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        i ? i.then(\n          F,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          F\n        ) : F();\n      }\n      this._invoke = n;\n    }\n    Y(I.prototype), w(I.prototype, m, function() {\n      return this;\n    }), s.AsyncIterator = I, s.async = function(t, e, r, i, n) {\n      n === void 0 && (n = Promise);\n      var d = new I(\n        C(t, e, r, i),\n        n\n      );\n      return s.isGeneratorFunction(e) ? d : d.next().then(function(b) {\n        return b.done ? b.value : d.next();\n      });\n    };\n    function V(t, e, r) {\n      var i = _;\n      return function(d, b) {\n        if (i === U)\n          throw new Error(\"Generator is already running\");\n        if (i === P) {\n          if (d === \"throw\")\n            throw b;\n          return g();\n        }\n        for (r.method = d, r.arg = b; ; ) {\n          var F = r.delegate;\n          if (F) {\n            var S = q(F, r);\n            if (S) {\n              if (S === L)\n                continue;\n              return S;\n            }\n          }\n          if (r.method === \"next\")\n            r.sent = r._sent = r.arg;\n          else if (r.method === \"throw\") {\n            if (i === _)\n              throw i = P, r.arg;\n            r.dispatchException(r.arg);\n          } else\n            r.method === \"return\" && r.abrupt(\"return\", r.arg);\n          i = U;\n          var E = N(t, e, r);\n          if (E.type === \"normal\") {\n            if (i = r.done ? P : G, E.arg === L)\n              continue;\n            return {\n              value: E.arg,\n              done: r.done\n            };\n          } else\n            E.type === \"throw\" && (i = P, r.method = \"throw\", r.arg = E.arg);\n        }\n      };\n    }\n    function q(t, e) {\n      var r = t.iterator[e.method];\n      if (r === l) {\n        if (e.delegate = null, e.method === \"throw\") {\n          if (t.iterator.return && (e.method = \"return\", e.arg = l, q(t, e), e.method === \"throw\"))\n            return L;\n          e.method = \"throw\", e.arg = new TypeError(\n            \"The iterator does not provide a 'throw' method\"\n          );\n        }\n        return L;\n      }\n      var i = N(r, t.iterator, e.arg);\n      if (i.type === \"throw\")\n        return e.method = \"throw\", e.arg = i.arg, e.delegate = null, L;\n      var n = i.arg;\n      if (!n)\n        return e.method = \"throw\", e.arg = new TypeError(\"iterator result is not an object\"), e.delegate = null, L;\n      if (n.done)\n        e[t.resultName] = n.value, e.next = t.nextLoc, e.method !== \"return\" && (e.method = \"next\", e.arg = l);\n      else\n        return n;\n      return e.delegate = null, L;\n    }\n    Y($), w($, v, \"Generator\"), w($, y, function() {\n      return this;\n    }), w($, \"toString\", function() {\n      return \"[object Generator]\";\n    });\n    function x(t) {\n      var e = { tryLoc: t[0] };\n      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n    }\n    function a(t) {\n      var e = t.completion || {};\n      e.type = \"normal\", delete e.arg, t.completion = e;\n    }\n    function u(t) {\n      this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(x, this), this.reset(!0);\n    }\n    s.keys = function(t) {\n      var e = [];\n      for (var r in t)\n        e.push(r);\n      return e.reverse(), function i() {\n        for (; e.length; ) {\n          var n = e.pop();\n          if (n in t)\n            return i.value = n, i.done = !1, i;\n        }\n        return i.done = !0, i;\n      };\n    };\n    function h(t) {\n      if (t) {\n        var e = t[y];\n        if (e)\n          return e.call(t);\n        if (typeof t.next == \"function\")\n          return t;\n        if (!isNaN(t.length)) {\n          var r = -1, i = function n() {\n            for (; ++r < t.length; )\n              if (c.call(t, r))\n                return n.value = t[r], n.done = !1, n;\n            return n.value = l, n.done = !0, n;\n          };\n          return i.next = i;\n        }\n      }\n      return { next: g };\n    }\n    s.values = h;\n    function g() {\n      return { value: l, done: !0 };\n    }\n    return u.prototype = {\n      constructor: u,\n      reset: function(t) {\n        if (this.prev = 0, this.next = 0, this.sent = this._sent = l, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = l, this.tryEntries.forEach(a), !t)\n          for (var e in this)\n            e.charAt(0) === \"t\" && c.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = l);\n      },\n      stop: function() {\n        this.done = !0;\n        var t = this.tryEntries[0], e = t.completion;\n        if (e.type === \"throw\")\n          throw e.arg;\n        return this.rval;\n      },\n      dispatchException: function(t) {\n        if (this.done)\n          throw t;\n        var e = this;\n        function r(S, E) {\n          return d.type = \"throw\", d.arg = t, e.next = S, E && (e.method = \"next\", e.arg = l), !!E;\n        }\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var n = this.tryEntries[i], d = n.completion;\n          if (n.tryLoc === \"root\")\n            return r(\"end\");\n          if (n.tryLoc <= this.prev) {\n            var b = c.call(n, \"catchLoc\"), F = c.call(n, \"finallyLoc\");\n            if (b && F) {\n              if (this.prev < n.catchLoc)\n                return r(n.catchLoc, !0);\n              if (this.prev < n.finallyLoc)\n                return r(n.finallyLoc);\n            } else if (b) {\n              if (this.prev < n.catchLoc)\n                return r(n.catchLoc, !0);\n            } else if (F) {\n              if (this.prev < n.finallyLoc)\n                return r(n.finallyLoc);\n            } else\n              throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      },\n      abrupt: function(t, e) {\n        for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n          var i = this.tryEntries[r];\n          if (i.tryLoc <= this.prev && c.call(i, \"finallyLoc\") && this.prev < i.finallyLoc) {\n            var n = i;\n            break;\n          }\n        }\n        n && (t === \"break\" || t === \"continue\") && n.tryLoc <= e && e <= n.finallyLoc && (n = null);\n        var d = n ? n.completion : {};\n        return d.type = t, d.arg = e, n ? (this.method = \"next\", this.next = n.finallyLoc, L) : this.complete(d);\n      },\n      complete: function(t, e) {\n        if (t.type === \"throw\")\n          throw t.arg;\n        return t.type === \"break\" || t.type === \"continue\" ? this.next = t.arg : t.type === \"return\" ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : t.type === \"normal\" && e && (this.next = e), L;\n      },\n      finish: function(t) {\n        for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n          var r = this.tryEntries[e];\n          if (r.finallyLoc === t)\n            return this.complete(r.completion, r.afterLoc), a(r), L;\n        }\n      },\n      catch: function(t) {\n        for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n          var r = this.tryEntries[e];\n          if (r.tryLoc === t) {\n            var i = r.completion;\n            if (i.type === \"throw\") {\n              var n = i.arg;\n              a(r);\n            }\n            return n;\n          }\n        }\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function(t, e, r) {\n        return this.delegate = {\n          iterator: h(t),\n          resultName: e,\n          nextLoc: r\n        }, this.method === \"next\" && (this.arg = l), L;\n      }\n    }, s;\n  }(\n    // If this script is executing as a CommonJS module, use module.exports\n    // as the regeneratorRuntime namespace. Otherwise create a new empty\n    // object. Either way, the resulting object will be used to initialize\n    // the regeneratorRuntime variable at the top of this file.\n    o.exports\n  );\n  try {\n    regeneratorRuntime = f;\n  } catch {\n    typeof globalThis == \"object\" ? globalThis.regeneratorRuntime = f : Function(\"r\", \"regeneratorRuntime = r\")(f);\n  }\n})(ie);\nvar ae = {\n  defaultArgs: [\n    /* args[0] is always the binary path */\n    \"./ffmpeg\",\n    /* Disable interaction mode */\n    \"-nostdin\",\n    /* Force to override output file */\n    \"-y\"\n  ],\n  baseOptions: {\n    /* Flag to turn on/off log messages in console */\n    log: !1,\n    /*\n     * Custom logger to get ffmpeg.wasm output messages.\n     * a sample logger looks like this:\n     *\n     * ```\n     * logger = ({ type, message }) => {\n     *   console.log(type, message);\n     * }\n     * ```\n     *\n     * type can be one of following:\n     *\n     * info: internal workflow debug messages\n     * fferr: ffmpeg native stderr output\n     * ffout: ffmpeg native stdout output\n     */\n    logger: () => {\n    },\n    /*\n     * Progress handler to get current progress of ffmpeg command.\n     * a sample progress handler looks like this:\n     *\n     * ```\n     * progress = ({ ratio }) => {\n     *   console.log(ratio);\n     * }\n     * ```\n     *\n     * ratio is a float number between 0 to 1.\n     */\n    progress: () => {\n    },\n    /*\n     * Path to find/download ffmpeg.wasm-core,\n     * this value should be overwriten by `defaultOptions` in\n     * each environment.\n     */\n    corePath: \"\"\n  }\n}, se = (o, f) => {\n  const s = o._malloc(f.length * Uint32Array.BYTES_PER_ELEMENT);\n  return f.forEach((p, c) => {\n    const l = o.lengthBytesUTF8(p) + 1, j = o._malloc(l);\n    o.stringToUTF8(p, j, l), o.setValue(s + Uint32Array.BYTES_PER_ELEMENT * c, j, \"i32\");\n  }), [f.length, s];\n};\nconst fe = \"@ffmpeg/ffmpeg\", ce = \"0.11.6\", le = \"FFmpeg WebAssembly version\", pe = \"src/index.js\", ue = \"src/index.d.ts\", he = {\n  example: \"examples\"\n}, de = {\n  start: \"node scripts/server.js\",\n  \"start:worker\": \"node scripts/worker-server.js\",\n  build: \"rimraf dist && webpack --config scripts/webpack.config.prod.js\",\n  \"build:worker\": \"rimraf dist && webpack --config scripts/webpack.config.worker.prod.js\",\n  prepublishOnly: \"npm run build\",\n  lint: \"eslint src\",\n  wait: \"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js\",\n  test: \"npm-run-all -p -r start test:all\",\n  \"test:all\": \"npm-run-all wait test:browser:ffmpeg test:node:all\",\n  \"test:node\": \"node node_modules/mocha/bin/_mocha --exit --bail --require ./scripts/test-helper.js\",\n  \"test:node:all\": \"npm run test:node -- ./tests/*.test.js\",\n  \"test:browser\": \"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000\",\n  \"test:browser:ffmpeg\": \"npm run test:browser -- -f ./tests/ffmpeg.test.html\"\n}, me = {\n  \"./src/node/index.js\": \"./src/browser/index.js\"\n}, ge = {\n  type: \"git\",\n  url: \"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git\"\n}, we = [\n  \"ffmpeg\",\n  \"WebAssembly\",\n  \"video\"\n], ye = \"Jerome Wu <jeromewus@gmail.com>\", ve = \"MIT\", be = {\n  url: \"https://github.com/ffmpegwasm/ffmpeg.wasm/issues\"\n}, Fe = {\n  node: \">=12.16.1\"\n}, Ee = \"https://github.com/ffmpegwasm/ffmpeg.wasm#readme\", je = {\n  \"is-url\": \"^1.2.4\",\n  \"node-fetch\": \"^2.6.1\",\n  \"regenerator-runtime\": \"^0.13.7\",\n  \"resolve-url\": \"^0.2.1\"\n}, Le = {\n  \"@babel/core\": \"^7.12.3\",\n  \"@babel/preset-env\": \"^7.12.1\",\n  \"@ffmpeg/core\": \"^0.11.0\",\n  \"@types/emscripten\": \"^1.39.4\",\n  \"babel-eslint\": \"^10.1.0\",\n  \"babel-loader\": \"^8.1.0\",\n  chai: \"^4.2.0\",\n  cors: \"^2.8.5\",\n  eslint: \"^7.12.1\",\n  \"eslint-config-airbnb-base\": \"^14.1.0\",\n  \"eslint-plugin-import\": \"^2.22.1\",\n  express: \"^4.17.1\",\n  mocha: \"^8.2.1\",\n  \"mocha-headless-chrome\": \"^2.0.3\",\n  \"npm-run-all\": \"^4.1.5\",\n  \"wait-on\": \"^5.3.0\",\n  webpack: \"^5.3.2\",\n  \"webpack-cli\": \"^4.1.0\",\n  \"webpack-dev-middleware\": \"^4.0.0\"\n}, Q = {\n  name: fe,\n  version: ce,\n  description: le,\n  main: pe,\n  types: ue,\n  directories: he,\n  scripts: de,\n  browser: me,\n  repository: ge,\n  keywords: we,\n  author: ye,\n  license: ve,\n  bugs: be,\n  engines: Fe,\n  homepage: Ee,\n  dependencies: je,\n  devDependencies: Le\n}, Oe = typeof process < \"u\" && \"development\" === \"development\" ? new URL(\"/node_modules/@ffmpeg/core/dist/ffmpeg-core.js\", self.location).href : `https://unpkg.com/@ffmpeg/core@${Q.devDependencies[\"@ffmpeg/core\"].substring(1)}/dist/ffmpeg-core.js`, Se = { corePath: Oe };\nlet Z = !1, X = () => {\n};\nconst _e = (o) => {\n  Z = o;\n}, Pe = (o) => {\n  X = o;\n}, ke = (o, f) => {\n  X({ type: o, message: f }), Z && console.log(`[${o}] ${f}`);\n};\nvar A = {\n  logging: Z,\n  setLogging: _e,\n  setCustomLogger: Pe,\n  log: ke\n};\nconst $e = (o) => `\ncreateFFmpegCore is not defined. ffmpeg.wasm is unable to find createFFmpegCore after loading ffmpeg-core.js from ${o}. Use another URL when calling createFFmpeg():\n\nconst ffmpeg = createFFmpeg({\n  corePath: 'http://localhost:3000/ffmpeg-core.js',\n});\n`;\nvar K = {\n  CREATE_FFMPEG_CORE_IS_NOT_DEFINED: $e\n};\nconst W = async (o, f) => {\n  A.log(\"info\", `fetch ${o}`);\n  const s = await (await fetch(o)).arrayBuffer();\n  A.log(\"info\", `${o} file size = ${s.byteLength} bytes`);\n  const p = new Blob([s], { type: f }), c = URL.createObjectURL(p);\n  return A.log(\"info\", `${o} blob URL = ${c}`), c;\n}, Ce = async ({\n  corePath: o,\n  workerPath: f,\n  wasmPath: s\n}) => {\n  if (typeof WorkerGlobalScope < \"u\" && self instanceof WorkerGlobalScope) {\n    if (typeof o != \"string\")\n      throw Error(\"corePath should be a string!\");\n    const y = new URL(o, \"file:///Users/bhavyagiri/Developer/react-whisper/web/node_modules/react-audio-voice-recorder/dist/index-1c988149.js\").href, m = await W(\n      y,\n      \"application/javascript\"\n    ), v = await W(\n      s !== void 0 ? s : y.replace(\"ffmpeg-core.js\", \"ffmpeg-core.wasm\"),\n      \"application/wasm\"\n    ), w = await W(\n      f !== void 0 ? f : y.replace(\"ffmpeg-core.js\", \"ffmpeg-core.worker.js\"),\n      \"application/javascript\"\n    );\n    return typeof createFFmpegCore > \"u\" ? new Promise((C) => {\n      if (globalThis.importScripts(m), typeof createFFmpegCore > \"u\")\n        throw Error(K.CREATE_FFMPEG_CORE_IS_NOT_DEFINED(y));\n      A.log(\"info\", \"ffmpeg-core.js script loaded\"), C({\n        createFFmpegCore,\n        corePath: m,\n        wasmPath: v,\n        workerPath: w\n      });\n    }) : (A.log(\"info\", \"ffmpeg-core.js script is loaded already\"), Promise.resolve({\n      createFFmpegCore,\n      corePath: m,\n      wasmPath: v,\n      workerPath: w\n    }));\n  }\n  if (typeof o != \"string\")\n    throw Error(\"corePath should be a string!\");\n  const p = new URL(o, \"file:///Users/bhavyagiri/Developer/react-whisper/web/node_modules/react-audio-voice-recorder/dist/index-1c988149.js\").href, c = await W(\n    p,\n    \"application/javascript\"\n  ), l = await W(\n    s !== void 0 ? s : p.replace(\"ffmpeg-core.js\", \"ffmpeg-core.wasm\"),\n    \"application/wasm\"\n  ), j = await W(\n    f !== void 0 ? f : p.replace(\"ffmpeg-core.js\", \"ffmpeg-core.worker.js\"),\n    \"application/javascript\"\n  );\n  return typeof createFFmpegCore > \"u\" ? new Promise((y) => {\n    const m = document.createElement(\"script\"), v = () => {\n      if (m.removeEventListener(\"load\", v), typeof createFFmpegCore > \"u\")\n        throw Error(K.CREATE_FFMPEG_CORE_IS_NOT_DEFINED(p));\n      A.log(\"info\", \"ffmpeg-core.js script loaded\"), y({\n        createFFmpegCore,\n        corePath: c,\n        wasmPath: l,\n        workerPath: j\n      });\n    };\n    m.src = c, m.type = \"text/javascript\", m.addEventListener(\"load\", v), document.getElementsByTagName(\"head\")[0].appendChild(m);\n  }) : (A.log(\"info\", \"ffmpeg-core.js script is loaded already\"), Promise.resolve({\n    createFFmpegCore,\n    corePath: c,\n    wasmPath: l,\n    workerPath: j\n  }));\n}, Te = (o) => new Promise((f, s) => {\n  const p = new FileReader();\n  p.onload = () => {\n    f(p.result);\n  }, p.onerror = ({ target: { error: { code: c } } }) => {\n    s(Error(`File could not be read! Code=${c}`));\n  }, p.readAsArrayBuffer(o);\n}), Re = async (o) => {\n  let f = o;\n  return typeof o > \"u\" ? new Uint8Array() : (typeof o == \"string\" ? /data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(o) ? f = atob(o.split(\",\")[1]).split(\"\").map((s) => s.charCodeAt(0)) : f = await (await fetch(new URL(o, \"file:///Users/bhavyagiri/Developer/react-whisper/web/node_modules/react-audio-voice-recorder/dist/index-1c988149.js\").href)).arrayBuffer() : (o instanceof File || o instanceof Blob) && (f = await Te(o)), new Uint8Array(f));\n}, Ae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  defaultOptions: Se,\n  fetchFile: Re,\n  getCreateFFmpegCore: Ce\n}, Symbol.toStringTag, { value: \"Module\" })), ee = /* @__PURE__ */ ne(Ae), { defaultArgs: Ne, baseOptions: Ge } = ae, Ue = se, { defaultOptions: De, getCreateFFmpegCore: Me } = ee, { version: Ie } = Q, J = Error(\"ffmpeg.wasm is not ready, make sure you have completed load().\");\nvar We = (o = {}) => {\n  const {\n    log: f,\n    logger: s,\n    progress: p,\n    ...c\n  } = {\n    ...Ge,\n    ...De,\n    ...o\n  };\n  let l = null, j = null, y = null, m = null, v = !1, w = () => {\n  }, C = f, N = p, _ = 0, G = 0, U = !1, P = 0;\n  const L = (a) => {\n    a === \"FFMPEG_END\" && y !== null && (y(), y = null, m = null, v = !1);\n  }, O = (a, u) => {\n    w({ type: a, message: u }), C && console.log(`[${a}] ${u}`);\n  }, T = (a) => {\n    const [u, h, g] = a.split(\":\");\n    return parseFloat(u) * 60 * 60 + parseFloat(h) * 60 + parseFloat(g);\n  }, k = (a, u) => {\n    if (typeof a == \"string\")\n      if (a.startsWith(\"  Duration\")) {\n        const h = a.split(\", \")[0].split(\": \")[1], g = T(h);\n        u({ duration: g, ratio: P }), (_ === 0 || _ > g) && (_ = g, U = !0);\n      } else if (U && a.startsWith(\"    Stream\")) {\n        const h = a.match(/([\\d.]+) fps/);\n        if (h) {\n          const g = parseFloat(h[1]);\n          G = _ * g;\n        } else\n          G = 0;\n        U = !1;\n      } else if (a.startsWith(\"frame\") || a.startsWith(\"size\")) {\n        const h = a.split(\"time=\")[1].split(\" \")[0], g = T(h), t = a.match(/frame=\\s*(\\d+)/);\n        if (G && t) {\n          const e = parseFloat(t[1]);\n          P = Math.min(e / G, 1);\n        } else\n          P = g / _;\n        u({ ratio: P, time: g });\n      } else\n        a.startsWith(\"video:\") && (u({ ratio: 1 }), _ = 0);\n  }, D = ({ type: a, message: u }) => {\n    O(a, u), k(u, N), L(u);\n  }, B = async () => {\n    if (O(\"info\", \"load ffmpeg-core\"), l === null) {\n      O(\"info\", \"loading ffmpeg-core\");\n      const {\n        createFFmpegCore: a,\n        corePath: u,\n        workerPath: h,\n        wasmPath: g\n      } = await Me(c);\n      l = await a({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: u,\n        printErr: (t) => D({ type: \"fferr\", message: t }),\n        print: (t) => D({ type: \"ffout\", message: t }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (t, e) => {\n          if (typeof window < \"u\" || typeof WorkerGlobalScope < \"u\") {\n            if (typeof g < \"u\" && t.endsWith(\"ffmpeg-core.wasm\"))\n              return g;\n            if (typeof h < \"u\" && t.endsWith(\"ffmpeg-core.worker.js\"))\n              return h;\n          }\n          return e + t;\n        }\n      }), j = l.cwrap(c.mainName || \"proxy_main\", \"number\", [\"number\", \"number\"]), O(\"info\", \"ffmpeg-core loaded\");\n    } else\n      throw Error(\"ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.\");\n  }, M = () => l !== null, $ = (...a) => {\n    if (O(\"info\", `run ffmpeg command: ${a.join(\" \")}`), l === null)\n      throw J;\n    if (v)\n      throw Error(\"ffmpeg.wasm can only run one command at a time\");\n    return v = !0, new Promise((u, h) => {\n      const g = [...Ne, ...a].filter((t) => t.length !== 0);\n      y = u, m = h, j(...Ue(l, g));\n    });\n  }, Y = (a, ...u) => {\n    if (O(\"info\", `run FS.${a} ${u.map((h) => typeof h == \"string\" ? h : `<${h.length} bytes binary file>`).join(\" \")}`), l === null)\n      throw J;\n    {\n      let h = null;\n      try {\n        h = l.FS[a](...u);\n      } catch {\n        throw Error(a === \"readdir\" ? `ffmpeg.FS('readdir', '${u[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')` : a === \"readFile\" ? `ffmpeg.FS('readFile', '${u[0]}') error. Check if the path exists` : \"Oops, something went wrong in FS operation.\");\n      }\n      return h;\n    }\n  }, I = () => {\n    if (l === null)\n      throw J;\n    m && m(\"ffmpeg has exited\"), v = !1;\n    try {\n      l.exit(1);\n    } catch (a) {\n      O(a.message), m && m(a);\n    } finally {\n      l = null, j = null, y = null, m = null;\n    }\n  }, V = (a) => {\n    N = a;\n  }, q = (a) => {\n    w = a;\n  }, x = (a) => {\n    C = a;\n  };\n  return O(\"info\", `use ffmpeg.wasm v${Ie}`), {\n    setProgress: V,\n    setLogger: q,\n    setLogging: x,\n    load: B,\n    isLoaded: M,\n    run: $,\n    exit: I,\n    FS: Y\n  };\n};\nconst Be = We, { fetchFile: ze } = ee;\nvar te = {\n  /*\n   * Create ffmpeg instance.\n   * Each ffmpeg instance owns an isolated MEMFS and works\n   * independently.\n   *\n   * For example:\n   *\n   * ```\n   * const ffmpeg = createFFmpeg({\n   *  log: true,\n   *  logger: () => {},\n   *  progress: () => {},\n   *  corePath: '',\n   * })\n   * ```\n   *\n   * For the usage of these four arguments, check config.js\n   *\n   */\n  createFFmpeg: Be,\n  /*\n   * Helper function for fetching files from various resource.\n   * Sometimes the video/audio file you want to process may located\n   * in a remote URL and somewhere in your local file system.\n   *\n   * This helper function helps you to fetch to file and return an\n   * Uint8Array variable for ffmpeg.wasm to consume.\n   *\n   */\n  fetchFile: ze\n};\nconst Ye = /* @__PURE__ */ oe(te), qe = /* @__PURE__ */ re({\n  __proto__: null,\n  default: Ye\n}, [te]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtYXVkaW8tdm9pY2UtcmVjb3JkZXIvZGlzdC9pbmRleC0xYzk4ODE0OS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVTtBQUNWLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxjQUFjLE9BQU8sVUFBVSxhQUFvQix1SUFBdUksK0NBQStDLDhCQUE4QjtBQUN4UTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRCxNQUFNLHFCQUFxQix3QkFBd0IsRUFBRSxJQUFJLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCxFQUFFOztBQUV0SDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQjtBQUNBLG1CQUFtQixHQUFHLGNBQWMsY0FBYztBQUNsRCw0QkFBNEIsU0FBUztBQUNyQywwQkFBMEIsR0FBRyxhQUFhLEVBQUU7QUFDNUMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUhBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFIQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlCQUFpQixVQUFVLFNBQVMsYUFBYTtBQUNwRCw0Q0FBNEMsRUFBRTtBQUM5QyxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsOEZBQThGLDhIQUE4SCxxSEFBZTtBQUMzTyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUIsbUNBQW1DLG1DQUFtQyxpQkFBaUIsOENBQThDLFFBQVEsY0FBYztBQUNyTSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsUUFBUSxxQkFBcUIsd0JBQXdCLEVBQUUsSUFBSSxFQUFFO0FBQzdELEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0IsUUFBUTtBQUNSLHVDQUF1QyxVQUFVO0FBQ2pELEdBQUcsU0FBUyxxQkFBcUI7QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RCwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNILHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsNEJBQTRCLEdBQUcsRUFBRSw0Q0FBNEMsVUFBVSwrQkFBK0I7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwrREFBK0QsS0FBSyxrSEFBa0gsS0FBSztBQUMzTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFHQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtYXVkaW8tdm9pY2UtcmVjb3JkZXIvZGlzdC9pbmRleC0xYzk4ODE0OS5qcz9lNGVmIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHJlKG8sIGYpIHtcbiAgZm9yICh2YXIgcyA9IDA7IHMgPCBmLmxlbmd0aDsgcysrKSB7XG4gICAgY29uc3QgcCA9IGZbc107XG4gICAgaWYgKHR5cGVvZiBwICE9IFwic3RyaW5nXCIgJiYgIUFycmF5LmlzQXJyYXkocCkpIHtcbiAgICAgIGZvciAoY29uc3QgYyBpbiBwKVxuICAgICAgICBpZiAoYyAhPT0gXCJkZWZhdWx0XCIgJiYgIShjIGluIG8pKSB7XG4gICAgICAgICAgY29uc3QgbCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgYyk7XG4gICAgICAgICAgbCAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgYywgbC5nZXQgPyBsIDoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHBbY11cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuZGVmaW5lUHJvcGVydHkobywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbn1cbmZ1bmN0aW9uIG9lKG8pIHtcbiAgcmV0dXJuIG8gJiYgby5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBcImRlZmF1bHRcIikgPyBvLmRlZmF1bHQgOiBvO1xufVxuZnVuY3Rpb24gbmUobykge1xuICBpZiAoby5fX2VzTW9kdWxlKVxuICAgIHJldHVybiBvO1xuICB2YXIgZiA9IG8uZGVmYXVsdDtcbiAgaWYgKHR5cGVvZiBmID09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBzID0gZnVuY3Rpb24gcCgpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgcCkge1xuICAgICAgICB2YXIgYyA9IFtudWxsXTtcbiAgICAgICAgYy5wdXNoLmFwcGx5KGMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBsID0gRnVuY3Rpb24uYmluZC5hcHBseShmLCBjKTtcbiAgICAgICAgcmV0dXJuIG5ldyBsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgcy5wcm90b3R5cGUgPSBmLnByb3RvdHlwZTtcbiAgfSBlbHNlXG4gICAgcyA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgdmFyIGMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sIHApO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBwLCBjLmdldCA/IGMgOiB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvW3BdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSwgcztcbn1cbnZhciBpZSA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihvKSB7XG4gIHZhciBmID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBwID0gT2JqZWN0LnByb3RvdHlwZSwgYyA9IHAuaGFzT3duUHJvcGVydHksIGwsIGogPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9LCB5ID0gai5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgbSA9IGouYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB2ID0gai50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcbiAgICBmdW5jdGlvbiB3KHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgZSwge1xuICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgfSksIHRbZV07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB3KHt9LCBcIlwiKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHcgPSBmdW5jdGlvbihlLCByLCBpKSB7XG4gICAgICAgIHJldHVybiBlW3JdID0gaTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEModCwgZSwgciwgaSkge1xuICAgICAgdmFyIG4gPSBlICYmIGUucHJvdG90eXBlIGluc3RhbmNlb2YgTyA/IGUgOiBPLCBkID0gT2JqZWN0LmNyZWF0ZShuLnByb3RvdHlwZSksIGIgPSBuZXcgdShpIHx8IFtdKTtcbiAgICAgIHJldHVybiBkLl9pbnZva2UgPSBWKHQsIHIsIGIpLCBkO1xuICAgIH1cbiAgICBzLndyYXAgPSBDO1xuICAgIGZ1bmN0aW9uIE4odCwgZSwgcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiB0LmNhbGwoZSwgcikgfTtcbiAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGkgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIF8gPSBcInN1c3BlbmRlZFN0YXJ0XCIsIEcgPSBcInN1c3BlbmRlZFlpZWxkXCIsIFUgPSBcImV4ZWN1dGluZ1wiLCBQID0gXCJjb21wbGV0ZWRcIiwgTCA9IHt9O1xuICAgIGZ1bmN0aW9uIE8oKSB7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFQoKSB7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGsoKSB7XG4gICAgfVxuICAgIHZhciBEID0ge307XG4gICAgdyhELCB5LCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICAgIHZhciBCID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBNID0gQiAmJiBCKEIoaChbXSkpKTtcbiAgICBNICYmIE0gIT09IHAgJiYgYy5jYWxsKE0sIHkpICYmIChEID0gTSk7XG4gICAgdmFyICQgPSBrLnByb3RvdHlwZSA9IE8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEKTtcbiAgICBULnByb3RvdHlwZSA9IGssIHcoJCwgXCJjb25zdHJ1Y3RvclwiLCBrKSwgdyhrLCBcImNvbnN0cnVjdG9yXCIsIFQpLCBULmRpc3BsYXlOYW1lID0gdyhcbiAgICAgIGssXG4gICAgICB2LFxuICAgICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgKTtcbiAgICBmdW5jdGlvbiBZKHQpIHtcbiAgICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdyh0LCBlLCBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShlLCByKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGUgPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgJiYgdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiBlID8gZSA9PT0gVCB8fCAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAoZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgOiAhMTtcbiAgICB9LCBzLm1hcmsgPSBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHQsIGspIDogKHQuX19wcm90b19fID0gaywgdyh0LCB2LCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCQpLCB0O1xuICAgIH0sIHMuYXdyYXAgPSBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4geyBfX2F3YWl0OiB0IH07XG4gICAgfTtcbiAgICBmdW5jdGlvbiBJKHQsIGUpIHtcbiAgICAgIGZ1bmN0aW9uIHIoZCwgYiwgRiwgUykge1xuICAgICAgICB2YXIgRSA9IE4odFtkXSwgdCwgYik7XG4gICAgICAgIGlmIChFLnR5cGUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICBTKEUuYXJnKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIEggPSBFLmFyZywgeiA9IEgudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHogJiYgdHlwZW9mIHogPT0gXCJvYmplY3RcIiAmJiBjLmNhbGwoeiwgXCJfX2F3YWl0XCIpID8gZS5yZXNvbHZlKHouX19hd2FpdCkudGhlbihmdW5jdGlvbihSKSB7XG4gICAgICAgICAgICByKFwibmV4dFwiLCBSLCBGLCBTKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihSKSB7XG4gICAgICAgICAgICByKFwidGhyb3dcIiwgUiwgRiwgUyk7XG4gICAgICAgICAgfSkgOiBlLnJlc29sdmUoeikudGhlbihmdW5jdGlvbihSKSB7XG4gICAgICAgICAgICBILnZhbHVlID0gUiwgRihIKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihSKSB7XG4gICAgICAgICAgICByZXR1cm4gcihcInRocm93XCIsIFIsIEYsIFMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaTtcbiAgICAgIGZ1bmN0aW9uIG4oZCwgYikge1xuICAgICAgICBmdW5jdGlvbiBGKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgZShmdW5jdGlvbihTLCBFKSB7XG4gICAgICAgICAgICByKGQsIGIsIFMsIEUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpID0gLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIGkgPyBpLnRoZW4oXG4gICAgICAgICAgRixcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBGXG4gICAgICAgICkgOiBGKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnZva2UgPSBuO1xuICAgIH1cbiAgICBZKEkucHJvdG90eXBlKSwgdyhJLnByb3RvdHlwZSwgbSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KSwgcy5Bc3luY0l0ZXJhdG9yID0gSSwgcy5hc3luYyA9IGZ1bmN0aW9uKHQsIGUsIHIsIGksIG4pIHtcbiAgICAgIG4gPT09IHZvaWQgMCAmJiAobiA9IFByb21pc2UpO1xuICAgICAgdmFyIGQgPSBuZXcgSShcbiAgICAgICAgQyh0LCBlLCByLCBpKSxcbiAgICAgICAgblxuICAgICAgKTtcbiAgICAgIHJldHVybiBzLmlzR2VuZXJhdG9yRnVuY3Rpb24oZSkgPyBkIDogZC5uZXh0KCkudGhlbihmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBiLmRvbmUgPyBiLnZhbHVlIDogZC5uZXh0KCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIFYodCwgZSwgcikge1xuICAgICAgdmFyIGkgPSBfO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQsIGIpIHtcbiAgICAgICAgaWYgKGkgPT09IFUpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgICAgaWYgKGkgPT09IFApIHtcbiAgICAgICAgICBpZiAoZCA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgICAgdGhyb3cgYjtcbiAgICAgICAgICByZXR1cm4gZygpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoci5tZXRob2QgPSBkLCByLmFyZyA9IGI7IDsgKSB7XG4gICAgICAgICAgdmFyIEYgPSByLmRlbGVnYXRlO1xuICAgICAgICAgIGlmIChGKSB7XG4gICAgICAgICAgICB2YXIgUyA9IHEoRiwgcik7XG4gICAgICAgICAgICBpZiAoUykge1xuICAgICAgICAgICAgICBpZiAoUyA9PT0gTClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyLm1ldGhvZCA9PT0gXCJuZXh0XCIpXG4gICAgICAgICAgICByLnNlbnQgPSByLl9zZW50ID0gci5hcmc7XG4gICAgICAgICAgZWxzZSBpZiAoci5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgaWYgKGkgPT09IF8pXG4gICAgICAgICAgICAgIHRocm93IGkgPSBQLCByLmFyZztcbiAgICAgICAgICAgIHIuZGlzcGF0Y2hFeGNlcHRpb24oci5hcmcpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgci5tZXRob2QgPT09IFwicmV0dXJuXCIgJiYgci5hYnJ1cHQoXCJyZXR1cm5cIiwgci5hcmcpO1xuICAgICAgICAgIGkgPSBVO1xuICAgICAgICAgIHZhciBFID0gTih0LCBlLCByKTtcbiAgICAgICAgICBpZiAoRS50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgICBpZiAoaSA9IHIuZG9uZSA/IFAgOiBHLCBFLmFyZyA9PT0gTClcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogRS5hcmcsXG4gICAgICAgICAgICAgIGRvbmU6IHIuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIEUudHlwZSA9PT0gXCJ0aHJvd1wiICYmIChpID0gUCwgci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gRS5hcmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBxKHQsIGUpIHtcbiAgICAgIHZhciByID0gdC5pdGVyYXRvcltlLm1ldGhvZF07XG4gICAgICBpZiAociA9PT0gbCkge1xuICAgICAgICBpZiAoZS5kZWxlZ2F0ZSA9IG51bGwsIGUubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAodC5pdGVyYXRvci5yZXR1cm4gJiYgKGUubWV0aG9kID0gXCJyZXR1cm5cIiwgZS5hcmcgPSBsLCBxKHQsIGUpLCBlLm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSlcbiAgICAgICAgICAgIHJldHVybiBMO1xuICAgICAgICAgIGUubWV0aG9kID0gXCJ0aHJvd1wiLCBlLmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEw7XG4gICAgICB9XG4gICAgICB2YXIgaSA9IE4ociwgdC5pdGVyYXRvciwgZS5hcmcpO1xuICAgICAgaWYgKGkudHlwZSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICByZXR1cm4gZS5tZXRob2QgPSBcInRocm93XCIsIGUuYXJnID0gaS5hcmcsIGUuZGVsZWdhdGUgPSBudWxsLCBMO1xuICAgICAgdmFyIG4gPSBpLmFyZztcbiAgICAgIGlmICghbilcbiAgICAgICAgcmV0dXJuIGUubWV0aG9kID0gXCJ0aHJvd1wiLCBlLmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgZS5kZWxlZ2F0ZSA9IG51bGwsIEw7XG4gICAgICBpZiAobi5kb25lKVxuICAgICAgICBlW3QucmVzdWx0TmFtZV0gPSBuLnZhbHVlLCBlLm5leHQgPSB0Lm5leHRMb2MsIGUubWV0aG9kICE9PSBcInJldHVyblwiICYmIChlLm1ldGhvZCA9IFwibmV4dFwiLCBlLmFyZyA9IGwpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIHJldHVybiBlLmRlbGVnYXRlID0gbnVsbCwgTDtcbiAgICB9XG4gICAgWSgkKSwgdygkLCB2LCBcIkdlbmVyYXRvclwiKSwgdygkLCB5LCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLCB3KCQsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiB4KHQpIHtcbiAgICAgIHZhciBlID0geyB0cnlMb2M6IHRbMF0gfTtcbiAgICAgIDEgaW4gdCAmJiAoZS5jYXRjaExvYyA9IHRbMV0pLCAyIGluIHQgJiYgKGUuZmluYWxseUxvYyA9IHRbMl0sIGUuYWZ0ZXJMb2MgPSB0WzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEodCkge1xuICAgICAgdmFyIGUgPSB0LmNvbXBsZXRpb24gfHwge307XG4gICAgICBlLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgZS5hcmcsIHQuY29tcGxldGlvbiA9IGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHUodCkge1xuICAgICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdC5mb3JFYWNoKHgsIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTtcbiAgICB9XG4gICAgcy5rZXlzID0gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGUgPSBbXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdClcbiAgICAgICAgZS5wdXNoKHIpO1xuICAgICAgcmV0dXJuIGUucmV2ZXJzZSgpLCBmdW5jdGlvbiBpKCkge1xuICAgICAgICBmb3IgKDsgZS5sZW5ndGg7ICkge1xuICAgICAgICAgIHZhciBuID0gZS5wb3AoKTtcbiAgICAgICAgICBpZiAobiBpbiB0KVxuICAgICAgICAgICAgcmV0dXJuIGkudmFsdWUgPSBuLCBpLmRvbmUgPSAhMSwgaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaS5kb25lID0gITAsIGk7XG4gICAgICB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gaCh0KSB7XG4gICAgICBpZiAodCkge1xuICAgICAgICB2YXIgZSA9IHRbeV07XG4gICAgICAgIGlmIChlKVxuICAgICAgICAgIHJldHVybiBlLmNhbGwodCk7XG4gICAgICAgIGlmICh0eXBlb2YgdC5uZXh0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgaWYgKCFpc05hTih0Lmxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgciA9IC0xLCBpID0gZnVuY3Rpb24gbigpIHtcbiAgICAgICAgICAgIGZvciAoOyArK3IgPCB0Lmxlbmd0aDsgKVxuICAgICAgICAgICAgICBpZiAoYy5jYWxsKHQsIHIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBuLnZhbHVlID0gdFtyXSwgbi5kb25lID0gITEsIG47XG4gICAgICAgICAgICByZXR1cm4gbi52YWx1ZSA9IGwsIG4uZG9uZSA9ICEwLCBuO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGkubmV4dCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG5leHQ6IGcgfTtcbiAgICB9XG4gICAgcy52YWx1ZXMgPSBoO1xuICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZTogbCwgZG9uZTogITAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHUucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6IHUsXG4gICAgICByZXNldDogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IGwsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSBsLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChhKSwgIXQpXG4gICAgICAgICAgZm9yICh2YXIgZSBpbiB0aGlzKVxuICAgICAgICAgICAgZS5jaGFyQXQoMCkgPT09IFwidFwiICYmIGMuY2FsbCh0aGlzLCBlKSAmJiAhaXNOYU4oK2Uuc2xpY2UoMSkpICYmICh0aGlzW2VdID0gbCk7XG4gICAgICB9LFxuICAgICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9ICEwO1xuICAgICAgICB2YXIgdCA9IHRoaXMudHJ5RW50cmllc1swXSwgZSA9IHQuY29tcGxldGlvbjtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgIHRocm93IGUuYXJnO1xuICAgICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpXG4gICAgICAgICAgdGhyb3cgdDtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiByKFMsIEUpIHtcbiAgICAgICAgICByZXR1cm4gZC50eXBlID0gXCJ0aHJvd1wiLCBkLmFyZyA9IHQsIGUubmV4dCA9IFMsIEUgJiYgKGUubWV0aG9kID0gXCJuZXh0XCIsIGUuYXJnID0gbCksICEhRTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLnRyeUVudHJpZXNbaV0sIGQgPSBuLmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKG4udHJ5TG9jID09PSBcInJvb3RcIilcbiAgICAgICAgICAgIHJldHVybiByKFwiZW5kXCIpO1xuICAgICAgICAgIGlmIChuLnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICAgIHZhciBiID0gYy5jYWxsKG4sIFwiY2F0Y2hMb2NcIiksIEYgPSBjLmNhbGwobiwgXCJmaW5hbGx5TG9jXCIpO1xuICAgICAgICAgICAgaWYgKGIgJiYgRikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgbi5jYXRjaExvYylcbiAgICAgICAgICAgICAgICByZXR1cm4gcihuLmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBuLmZpbmFsbHlMb2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIobi5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgbi5jYXRjaExvYylcbiAgICAgICAgICAgICAgICByZXR1cm4gcihuLmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEYpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IG4uZmluYWxseUxvYylcbiAgICAgICAgICAgICAgICByZXR1cm4gcihuLmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFicnVwdDogZnVuY3Rpb24odCwgZSkge1xuICAgICAgICBmb3IgKHZhciByID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IHIgPj0gMDsgLS1yKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLnRyeUVudHJpZXNbcl07XG4gICAgICAgICAgaWYgKGkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBjLmNhbGwoaSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgdmFyIG4gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG4gJiYgKHQgPT09IFwiYnJlYWtcIiB8fCB0ID09PSBcImNvbnRpbnVlXCIpICYmIG4udHJ5TG9jIDw9IGUgJiYgZSA8PSBuLmZpbmFsbHlMb2MgJiYgKG4gPSBudWxsKTtcbiAgICAgICAgdmFyIGQgPSBuID8gbi5jb21wbGV0aW9uIDoge307XG4gICAgICAgIHJldHVybiBkLnR5cGUgPSB0LCBkLmFyZyA9IGUsIG4gPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gbi5maW5hbGx5TG9jLCBMKSA6IHRoaXMuY29tcGxldGUoZCk7XG4gICAgICB9LFxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgaWYgKHQudHlwZSA9PT0gXCJ0aHJvd1wiKVxuICAgICAgICAgIHRocm93IHQuYXJnO1xuICAgICAgICByZXR1cm4gdC50eXBlID09PSBcImJyZWFrXCIgfHwgdC50eXBlID09PSBcImNvbnRpbnVlXCIgPyB0aGlzLm5leHQgPSB0LmFyZyA6IHQudHlwZSA9PT0gXCJyZXR1cm5cIiA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogdC50eXBlID09PSBcIm5vcm1hbFwiICYmIGUgJiYgKHRoaXMubmV4dCA9IGUpLCBMO1xuICAgICAgfSxcbiAgICAgIGZpbmlzaDogZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBlID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLnRyeUVudHJpZXNbZV07XG4gICAgICAgICAgaWYgKHIuZmluYWxseUxvYyA9PT0gdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHIuY29tcGxldGlvbiwgci5hZnRlckxvYyksIGEociksIEw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYXRjaDogZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBlID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKSB7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLnRyeUVudHJpZXNbZV07XG4gICAgICAgICAgaWYgKHIudHJ5TG9jID09PSB0KSB7XG4gICAgICAgICAgICB2YXIgaSA9IHIuY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmIChpLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICB2YXIgbiA9IGkuYXJnO1xuICAgICAgICAgICAgICBhKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICAgIH0sXG4gICAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbih0LCBlLCByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICAgIGl0ZXJhdG9yOiBoKHQpLFxuICAgICAgICAgIHJlc3VsdE5hbWU6IGUsXG4gICAgICAgICAgbmV4dExvYzogclxuICAgICAgICB9LCB0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIgJiYgKHRoaXMuYXJnID0gbCksIEw7XG4gICAgICB9XG4gICAgfSwgcztcbiAgfShcbiAgICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAgIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gICAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAgIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gICAgby5leHBvcnRzXG4gICk7XG4gIHRyeSB7XG4gICAgcmVnZW5lcmF0b3JSdW50aW1lID0gZjtcbiAgfSBjYXRjaCB7XG4gICAgdHlwZW9mIGdsb2JhbFRoaXMgPT0gXCJvYmplY3RcIiA/IGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gZiA6IEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikoZik7XG4gIH1cbn0pKGllKTtcbnZhciBhZSA9IHtcbiAgZGVmYXVsdEFyZ3M6IFtcbiAgICAvKiBhcmdzWzBdIGlzIGFsd2F5cyB0aGUgYmluYXJ5IHBhdGggKi9cbiAgICBcIi4vZmZtcGVnXCIsXG4gICAgLyogRGlzYWJsZSBpbnRlcmFjdGlvbiBtb2RlICovXG4gICAgXCItbm9zdGRpblwiLFxuICAgIC8qIEZvcmNlIHRvIG92ZXJyaWRlIG91dHB1dCBmaWxlICovXG4gICAgXCIteVwiXG4gIF0sXG4gIGJhc2VPcHRpb25zOiB7XG4gICAgLyogRmxhZyB0byB0dXJuIG9uL29mZiBsb2cgbWVzc2FnZXMgaW4gY29uc29sZSAqL1xuICAgIGxvZzogITEsXG4gICAgLypcbiAgICAgKiBDdXN0b20gbG9nZ2VyIHRvIGdldCBmZm1wZWcud2FzbSBvdXRwdXQgbWVzc2FnZXMuXG4gICAgICogYSBzYW1wbGUgbG9nZ2VyIGxvb2tzIGxpa2UgdGhpczpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGxvZ2dlciA9ICh7IHR5cGUsIG1lc3NhZ2UgfSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2codHlwZSwgbWVzc2FnZSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogdHlwZSBjYW4gYmUgb25lIG9mIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqIGluZm86IGludGVybmFsIHdvcmtmbG93IGRlYnVnIG1lc3NhZ2VzXG4gICAgICogZmZlcnI6IGZmbXBlZyBuYXRpdmUgc3RkZXJyIG91dHB1dFxuICAgICAqIGZmb3V0OiBmZm1wZWcgbmF0aXZlIHN0ZG91dCBvdXRwdXRcbiAgICAgKi9cbiAgICBsb2dnZXI6ICgpID0+IHtcbiAgICB9LFxuICAgIC8qXG4gICAgICogUHJvZ3Jlc3MgaGFuZGxlciB0byBnZXQgY3VycmVudCBwcm9ncmVzcyBvZiBmZm1wZWcgY29tbWFuZC5cbiAgICAgKiBhIHNhbXBsZSBwcm9ncmVzcyBoYW5kbGVyIGxvb2tzIGxpa2UgdGhpczpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHByb2dyZXNzID0gKHsgcmF0aW8gfSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2cocmF0aW8pO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIHJhdGlvIGlzIGEgZmxvYXQgbnVtYmVyIGJldHdlZW4gMCB0byAxLlxuICAgICAqL1xuICAgIHByb2dyZXNzOiAoKSA9PiB7XG4gICAgfSxcbiAgICAvKlxuICAgICAqIFBhdGggdG8gZmluZC9kb3dubG9hZCBmZm1wZWcud2FzbS1jb3JlLFxuICAgICAqIHRoaXMgdmFsdWUgc2hvdWxkIGJlIG92ZXJ3cml0ZW4gYnkgYGRlZmF1bHRPcHRpb25zYCBpblxuICAgICAqIGVhY2ggZW52aXJvbm1lbnQuXG4gICAgICovXG4gICAgY29yZVBhdGg6IFwiXCJcbiAgfVxufSwgc2UgPSAobywgZikgPT4ge1xuICBjb25zdCBzID0gby5fbWFsbG9jKGYubGVuZ3RoICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpO1xuICByZXR1cm4gZi5mb3JFYWNoKChwLCBjKSA9PiB7XG4gICAgY29uc3QgbCA9IG8ubGVuZ3RoQnl0ZXNVVEY4KHApICsgMSwgaiA9IG8uX21hbGxvYyhsKTtcbiAgICBvLnN0cmluZ1RvVVRGOChwLCBqLCBsKSwgby5zZXRWYWx1ZShzICsgVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKiBjLCBqLCBcImkzMlwiKTtcbiAgfSksIFtmLmxlbmd0aCwgc107XG59O1xuY29uc3QgZmUgPSBcIkBmZm1wZWcvZmZtcGVnXCIsIGNlID0gXCIwLjExLjZcIiwgbGUgPSBcIkZGbXBlZyBXZWJBc3NlbWJseSB2ZXJzaW9uXCIsIHBlID0gXCJzcmMvaW5kZXguanNcIiwgdWUgPSBcInNyYy9pbmRleC5kLnRzXCIsIGhlID0ge1xuICBleGFtcGxlOiBcImV4YW1wbGVzXCJcbn0sIGRlID0ge1xuICBzdGFydDogXCJub2RlIHNjcmlwdHMvc2VydmVyLmpzXCIsXG4gIFwic3RhcnQ6d29ya2VyXCI6IFwibm9kZSBzY3JpcHRzL3dvcmtlci1zZXJ2ZXIuanNcIixcbiAgYnVpbGQ6IFwicmltcmFmIGRpc3QgJiYgd2VicGFjayAtLWNvbmZpZyBzY3JpcHRzL3dlYnBhY2suY29uZmlnLnByb2QuanNcIixcbiAgXCJidWlsZDp3b3JrZXJcIjogXCJyaW1yYWYgZGlzdCAmJiB3ZWJwYWNrIC0tY29uZmlnIHNjcmlwdHMvd2VicGFjay5jb25maWcud29ya2VyLnByb2QuanNcIixcbiAgcHJlcHVibGlzaE9ubHk6IFwibnBtIHJ1biBidWlsZFwiLFxuICBsaW50OiBcImVzbGludCBzcmNcIixcbiAgd2FpdDogXCJyaW1yYWYgZGlzdCAmJiB3YWl0LW9uIGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9kaXN0L2ZmbXBlZy5kZXYuanNcIixcbiAgdGVzdDogXCJucG0tcnVuLWFsbCAtcCAtciBzdGFydCB0ZXN0OmFsbFwiLFxuICBcInRlc3Q6YWxsXCI6IFwibnBtLXJ1bi1hbGwgd2FpdCB0ZXN0OmJyb3dzZXI6ZmZtcGVnIHRlc3Q6bm9kZTphbGxcIixcbiAgXCJ0ZXN0Om5vZGVcIjogXCJub2RlIG5vZGVfbW9kdWxlcy9tb2NoYS9iaW4vX21vY2hhIC0tZXhpdCAtLWJhaWwgLS1yZXF1aXJlIC4vc2NyaXB0cy90ZXN0LWhlbHBlci5qc1wiLFxuICBcInRlc3Q6bm9kZTphbGxcIjogXCJucG0gcnVuIHRlc3Q6bm9kZSAtLSAuL3Rlc3RzLyoudGVzdC5qc1wiLFxuICBcInRlc3Q6YnJvd3NlclwiOiBcIm1vY2hhLWhlYWRsZXNzLWNocm9tZSAtYSBhbGxvdy1maWxlLWFjY2Vzcy1mcm9tLWZpbGVzIC1hIGluY29nbml0byAtYSBuby1zYW5kYm94IC1hIGRpc2FibGUtc2V0dWlkLXNhbmRib3ggLWEgZGlzYWJsZS1sb2dnaW5nIC10IDMwMDAwMFwiLFxuICBcInRlc3Q6YnJvd3NlcjpmZm1wZWdcIjogXCJucG0gcnVuIHRlc3Q6YnJvd3NlciAtLSAtZiAuL3Rlc3RzL2ZmbXBlZy50ZXN0Lmh0bWxcIlxufSwgbWUgPSB7XG4gIFwiLi9zcmMvbm9kZS9pbmRleC5qc1wiOiBcIi4vc3JjL2Jyb3dzZXIvaW5kZXguanNcIlxufSwgZ2UgPSB7XG4gIHR5cGU6IFwiZ2l0XCIsXG4gIHVybDogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL2ZmbXBlZ3dhc20vZmZtcGVnLndhc20uZ2l0XCJcbn0sIHdlID0gW1xuICBcImZmbXBlZ1wiLFxuICBcIldlYkFzc2VtYmx5XCIsXG4gIFwidmlkZW9cIlxuXSwgeWUgPSBcIkplcm9tZSBXdSA8amVyb21ld3VzQGdtYWlsLmNvbT5cIiwgdmUgPSBcIk1JVFwiLCBiZSA9IHtcbiAgdXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9mZm1wZWd3YXNtL2ZmbXBlZy53YXNtL2lzc3Vlc1wiXG59LCBGZSA9IHtcbiAgbm9kZTogXCI+PTEyLjE2LjFcIlxufSwgRWUgPSBcImh0dHBzOi8vZ2l0aHViLmNvbS9mZm1wZWd3YXNtL2ZmbXBlZy53YXNtI3JlYWRtZVwiLCBqZSA9IHtcbiAgXCJpcy11cmxcIjogXCJeMS4yLjRcIixcbiAgXCJub2RlLWZldGNoXCI6IFwiXjIuNi4xXCIsXG4gIFwicmVnZW5lcmF0b3ItcnVudGltZVwiOiBcIl4wLjEzLjdcIixcbiAgXCJyZXNvbHZlLXVybFwiOiBcIl4wLjIuMVwiXG59LCBMZSA9IHtcbiAgXCJAYmFiZWwvY29yZVwiOiBcIl43LjEyLjNcIixcbiAgXCJAYmFiZWwvcHJlc2V0LWVudlwiOiBcIl43LjEyLjFcIixcbiAgXCJAZmZtcGVnL2NvcmVcIjogXCJeMC4xMS4wXCIsXG4gIFwiQHR5cGVzL2Vtc2NyaXB0ZW5cIjogXCJeMS4zOS40XCIsXG4gIFwiYmFiZWwtZXNsaW50XCI6IFwiXjEwLjEuMFwiLFxuICBcImJhYmVsLWxvYWRlclwiOiBcIl44LjEuMFwiLFxuICBjaGFpOiBcIl40LjIuMFwiLFxuICBjb3JzOiBcIl4yLjguNVwiLFxuICBlc2xpbnQ6IFwiXjcuMTIuMVwiLFxuICBcImVzbGludC1jb25maWctYWlyYm5iLWJhc2VcIjogXCJeMTQuMS4wXCIsXG4gIFwiZXNsaW50LXBsdWdpbi1pbXBvcnRcIjogXCJeMi4yMi4xXCIsXG4gIGV4cHJlc3M6IFwiXjQuMTcuMVwiLFxuICBtb2NoYTogXCJeOC4yLjFcIixcbiAgXCJtb2NoYS1oZWFkbGVzcy1jaHJvbWVcIjogXCJeMi4wLjNcIixcbiAgXCJucG0tcnVuLWFsbFwiOiBcIl40LjEuNVwiLFxuICBcIndhaXQtb25cIjogXCJeNS4zLjBcIixcbiAgd2VicGFjazogXCJeNS4zLjJcIixcbiAgXCJ3ZWJwYWNrLWNsaVwiOiBcIl40LjEuMFwiLFxuICBcIndlYnBhY2stZGV2LW1pZGRsZXdhcmVcIjogXCJeNC4wLjBcIlxufSwgUSA9IHtcbiAgbmFtZTogZmUsXG4gIHZlcnNpb246IGNlLFxuICBkZXNjcmlwdGlvbjogbGUsXG4gIG1haW46IHBlLFxuICB0eXBlczogdWUsXG4gIGRpcmVjdG9yaWVzOiBoZSxcbiAgc2NyaXB0czogZGUsXG4gIGJyb3dzZXI6IG1lLFxuICByZXBvc2l0b3J5OiBnZSxcbiAga2V5d29yZHM6IHdlLFxuICBhdXRob3I6IHllLFxuICBsaWNlbnNlOiB2ZSxcbiAgYnVnczogYmUsXG4gIGVuZ2luZXM6IEZlLFxuICBob21lcGFnZTogRWUsXG4gIGRlcGVuZGVuY2llczogamUsXG4gIGRldkRlcGVuZGVuY2llczogTGVcbn0sIE9lID0gdHlwZW9mIHByb2Nlc3MgPCBcInVcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiID8gbmV3IFVSTChcIi9ub2RlX21vZHVsZXMvQGZmbXBlZy9jb3JlL2Rpc3QvZmZtcGVnLWNvcmUuanNcIiwgc2VsZi5sb2NhdGlvbikuaHJlZiA6IGBodHRwczovL3VucGtnLmNvbS9AZmZtcGVnL2NvcmVAJHtRLmRldkRlcGVuZGVuY2llc1tcIkBmZm1wZWcvY29yZVwiXS5zdWJzdHJpbmcoMSl9L2Rpc3QvZmZtcGVnLWNvcmUuanNgLCBTZSA9IHsgY29yZVBhdGg6IE9lIH07XG5sZXQgWiA9ICExLCBYID0gKCkgPT4ge1xufTtcbmNvbnN0IF9lID0gKG8pID0+IHtcbiAgWiA9IG87XG59LCBQZSA9IChvKSA9PiB7XG4gIFggPSBvO1xufSwga2UgPSAobywgZikgPT4ge1xuICBYKHsgdHlwZTogbywgbWVzc2FnZTogZiB9KSwgWiAmJiBjb25zb2xlLmxvZyhgWyR7b31dICR7Zn1gKTtcbn07XG52YXIgQSA9IHtcbiAgbG9nZ2luZzogWixcbiAgc2V0TG9nZ2luZzogX2UsXG4gIHNldEN1c3RvbUxvZ2dlcjogUGUsXG4gIGxvZzoga2Vcbn07XG5jb25zdCAkZSA9IChvKSA9PiBgXG5jcmVhdGVGRm1wZWdDb3JlIGlzIG5vdCBkZWZpbmVkLiBmZm1wZWcud2FzbSBpcyB1bmFibGUgdG8gZmluZCBjcmVhdGVGRm1wZWdDb3JlIGFmdGVyIGxvYWRpbmcgZmZtcGVnLWNvcmUuanMgZnJvbSAke299LiBVc2UgYW5vdGhlciBVUkwgd2hlbiBjYWxsaW5nIGNyZWF0ZUZGbXBlZygpOlxuXG5jb25zdCBmZm1wZWcgPSBjcmVhdGVGRm1wZWcoe1xuICBjb3JlUGF0aDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9mZm1wZWctY29yZS5qcycsXG59KTtcbmA7XG52YXIgSyA9IHtcbiAgQ1JFQVRFX0ZGTVBFR19DT1JFX0lTX05PVF9ERUZJTkVEOiAkZVxufTtcbmNvbnN0IFcgPSBhc3luYyAobywgZikgPT4ge1xuICBBLmxvZyhcImluZm9cIiwgYGZldGNoICR7b31gKTtcbiAgY29uc3QgcyA9IGF3YWl0IChhd2FpdCBmZXRjaChvKSkuYXJyYXlCdWZmZXIoKTtcbiAgQS5sb2coXCJpbmZvXCIsIGAke299IGZpbGUgc2l6ZSA9ICR7cy5ieXRlTGVuZ3RofSBieXRlc2ApO1xuICBjb25zdCBwID0gbmV3IEJsb2IoW3NdLCB7IHR5cGU6IGYgfSksIGMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHApO1xuICByZXR1cm4gQS5sb2coXCJpbmZvXCIsIGAke299IGJsb2IgVVJMID0gJHtjfWApLCBjO1xufSwgQ2UgPSBhc3luYyAoe1xuICBjb3JlUGF0aDogbyxcbiAgd29ya2VyUGF0aDogZixcbiAgd2FzbVBhdGg6IHNcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA8IFwidVwiICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkge1xuICAgIGlmICh0eXBlb2YgbyAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgRXJyb3IoXCJjb3JlUGF0aCBzaG91bGQgYmUgYSBzdHJpbmchXCIpO1xuICAgIGNvbnN0IHkgPSBuZXcgVVJMKG8sIGltcG9ydC5tZXRhLnVybCkuaHJlZiwgbSA9IGF3YWl0IFcoXG4gICAgICB5LFxuICAgICAgXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCJcbiAgICApLCB2ID0gYXdhaXQgVyhcbiAgICAgIHMgIT09IHZvaWQgMCA/IHMgOiB5LnJlcGxhY2UoXCJmZm1wZWctY29yZS5qc1wiLCBcImZmbXBlZy1jb3JlLndhc21cIiksXG4gICAgICBcImFwcGxpY2F0aW9uL3dhc21cIlxuICAgICksIHcgPSBhd2FpdCBXKFxuICAgICAgZiAhPT0gdm9pZCAwID8gZiA6IHkucmVwbGFjZShcImZmbXBlZy1jb3JlLmpzXCIsIFwiZmZtcGVnLWNvcmUud29ya2VyLmpzXCIpLFxuICAgICAgXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCJcbiAgICApO1xuICAgIHJldHVybiB0eXBlb2YgY3JlYXRlRkZtcGVnQ29yZSA+IFwidVwiID8gbmV3IFByb21pc2UoKEMpID0+IHtcbiAgICAgIGlmIChnbG9iYWxUaGlzLmltcG9ydFNjcmlwdHMobSksIHR5cGVvZiBjcmVhdGVGRm1wZWdDb3JlID4gXCJ1XCIpXG4gICAgICAgIHRocm93IEVycm9yKEsuQ1JFQVRFX0ZGTVBFR19DT1JFX0lTX05PVF9ERUZJTkVEKHkpKTtcbiAgICAgIEEubG9nKFwiaW5mb1wiLCBcImZmbXBlZy1jb3JlLmpzIHNjcmlwdCBsb2FkZWRcIiksIEMoe1xuICAgICAgICBjcmVhdGVGRm1wZWdDb3JlLFxuICAgICAgICBjb3JlUGF0aDogbSxcbiAgICAgICAgd2FzbVBhdGg6IHYsXG4gICAgICAgIHdvcmtlclBhdGg6IHdcbiAgICAgIH0pO1xuICAgIH0pIDogKEEubG9nKFwiaW5mb1wiLCBcImZmbXBlZy1jb3JlLmpzIHNjcmlwdCBpcyBsb2FkZWQgYWxyZWFkeVwiKSwgUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGNyZWF0ZUZGbXBlZ0NvcmUsXG4gICAgICBjb3JlUGF0aDogbSxcbiAgICAgIHdhc21QYXRoOiB2LFxuICAgICAgd29ya2VyUGF0aDogd1xuICAgIH0pKTtcbiAgfVxuICBpZiAodHlwZW9mIG8gIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBFcnJvcihcImNvcmVQYXRoIHNob3VsZCBiZSBhIHN0cmluZyFcIik7XG4gIGNvbnN0IHAgPSBuZXcgVVJMKG8sIGltcG9ydC5tZXRhLnVybCkuaHJlZiwgYyA9IGF3YWl0IFcoXG4gICAgcCxcbiAgICBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIlxuICApLCBsID0gYXdhaXQgVyhcbiAgICBzICE9PSB2b2lkIDAgPyBzIDogcC5yZXBsYWNlKFwiZmZtcGVnLWNvcmUuanNcIiwgXCJmZm1wZWctY29yZS53YXNtXCIpLFxuICAgIFwiYXBwbGljYXRpb24vd2FzbVwiXG4gICksIGogPSBhd2FpdCBXKFxuICAgIGYgIT09IHZvaWQgMCA/IGYgOiBwLnJlcGxhY2UoXCJmZm1wZWctY29yZS5qc1wiLCBcImZmbXBlZy1jb3JlLndvcmtlci5qc1wiKSxcbiAgICBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIlxuICApO1xuICByZXR1cm4gdHlwZW9mIGNyZWF0ZUZGbXBlZ0NvcmUgPiBcInVcIiA/IG5ldyBQcm9taXNlKCh5KSA9PiB7XG4gICAgY29uc3QgbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksIHYgPSAoKSA9PiB7XG4gICAgICBpZiAobS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB2KSwgdHlwZW9mIGNyZWF0ZUZGbXBlZ0NvcmUgPiBcInVcIilcbiAgICAgICAgdGhyb3cgRXJyb3IoSy5DUkVBVEVfRkZNUEVHX0NPUkVfSVNfTk9UX0RFRklORUQocCkpO1xuICAgICAgQS5sb2coXCJpbmZvXCIsIFwiZmZtcGVnLWNvcmUuanMgc2NyaXB0IGxvYWRlZFwiKSwgeSh7XG4gICAgICAgIGNyZWF0ZUZGbXBlZ0NvcmUsXG4gICAgICAgIGNvcmVQYXRoOiBjLFxuICAgICAgICB3YXNtUGF0aDogbCxcbiAgICAgICAgd29ya2VyUGF0aDogalxuICAgICAgfSk7XG4gICAgfTtcbiAgICBtLnNyYyA9IGMsIG0udHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCIsIG0uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdiksIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChtKTtcbiAgfSkgOiAoQS5sb2coXCJpbmZvXCIsIFwiZmZtcGVnLWNvcmUuanMgc2NyaXB0IGlzIGxvYWRlZCBhbHJlYWR5XCIpLCBQcm9taXNlLnJlc29sdmUoe1xuICAgIGNyZWF0ZUZGbXBlZ0NvcmUsXG4gICAgY29yZVBhdGg6IGMsXG4gICAgd2FzbVBhdGg6IGwsXG4gICAgd29ya2VyUGF0aDogalxuICB9KSk7XG59LCBUZSA9IChvKSA9PiBuZXcgUHJvbWlzZSgoZiwgcykgPT4ge1xuICBjb25zdCBwID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgcC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgZihwLnJlc3VsdCk7XG4gIH0sIHAub25lcnJvciA9ICh7IHRhcmdldDogeyBlcnJvcjogeyBjb2RlOiBjIH0gfSB9KSA9PiB7XG4gICAgcyhFcnJvcihgRmlsZSBjb3VsZCBub3QgYmUgcmVhZCEgQ29kZT0ke2N9YCkpO1xuICB9LCBwLnJlYWRBc0FycmF5QnVmZmVyKG8pO1xufSksIFJlID0gYXN5bmMgKG8pID0+IHtcbiAgbGV0IGYgPSBvO1xuICByZXR1cm4gdHlwZW9mIG8gPiBcInVcIiA/IG5ldyBVaW50OEFycmF5KCkgOiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IC9kYXRhOl9kYXRhXFwvKFthLXpBLVpdKik7YmFzZTY0LChbXlwiXSopLy50ZXN0KG8pID8gZiA9IGF0b2Ioby5zcGxpdChcIixcIilbMV0pLnNwbGl0KFwiXCIpLm1hcCgocykgPT4gcy5jaGFyQ29kZUF0KDApKSA6IGYgPSBhd2FpdCAoYXdhaXQgZmV0Y2gobmV3IFVSTChvLCBpbXBvcnQubWV0YS51cmwpLmhyZWYpKS5hcnJheUJ1ZmZlcigpIDogKG8gaW5zdGFuY2VvZiBGaWxlIHx8IG8gaW5zdGFuY2VvZiBCbG9iKSAmJiAoZiA9IGF3YWl0IFRlKG8pKSwgbmV3IFVpbnQ4QXJyYXkoZikpO1xufSwgQWUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkZWZhdWx0T3B0aW9uczogU2UsXG4gIGZldGNoRmlsZTogUmUsXG4gIGdldENyZWF0ZUZGbXBlZ0NvcmU6IENlXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBlZSA9IC8qIEBfX1BVUkVfXyAqLyBuZShBZSksIHsgZGVmYXVsdEFyZ3M6IE5lLCBiYXNlT3B0aW9uczogR2UgfSA9IGFlLCBVZSA9IHNlLCB7IGRlZmF1bHRPcHRpb25zOiBEZSwgZ2V0Q3JlYXRlRkZtcGVnQ29yZTogTWUgfSA9IGVlLCB7IHZlcnNpb246IEllIH0gPSBRLCBKID0gRXJyb3IoXCJmZm1wZWcud2FzbSBpcyBub3QgcmVhZHksIG1ha2Ugc3VyZSB5b3UgaGF2ZSBjb21wbGV0ZWQgbG9hZCgpLlwiKTtcbnZhciBXZSA9IChvID0ge30pID0+IHtcbiAgY29uc3Qge1xuICAgIGxvZzogZixcbiAgICBsb2dnZXI6IHMsXG4gICAgcHJvZ3Jlc3M6IHAsXG4gICAgLi4uY1xuICB9ID0ge1xuICAgIC4uLkdlLFxuICAgIC4uLkRlLFxuICAgIC4uLm9cbiAgfTtcbiAgbGV0IGwgPSBudWxsLCBqID0gbnVsbCwgeSA9IG51bGwsIG0gPSBudWxsLCB2ID0gITEsIHcgPSAoKSA9PiB7XG4gIH0sIEMgPSBmLCBOID0gcCwgXyA9IDAsIEcgPSAwLCBVID0gITEsIFAgPSAwO1xuICBjb25zdCBMID0gKGEpID0+IHtcbiAgICBhID09PSBcIkZGTVBFR19FTkRcIiAmJiB5ICE9PSBudWxsICYmICh5KCksIHkgPSBudWxsLCBtID0gbnVsbCwgdiA9ICExKTtcbiAgfSwgTyA9IChhLCB1KSA9PiB7XG4gICAgdyh7IHR5cGU6IGEsIG1lc3NhZ2U6IHUgfSksIEMgJiYgY29uc29sZS5sb2coYFske2F9XSAke3V9YCk7XG4gIH0sIFQgPSAoYSkgPT4ge1xuICAgIGNvbnN0IFt1LCBoLCBnXSA9IGEuc3BsaXQoXCI6XCIpO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHUpICogNjAgKiA2MCArIHBhcnNlRmxvYXQoaCkgKiA2MCArIHBhcnNlRmxvYXQoZyk7XG4gIH0sIGsgPSAoYSwgdSkgPT4ge1xuICAgIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiKVxuICAgICAgaWYgKGEuc3RhcnRzV2l0aChcIiAgRHVyYXRpb25cIikpIHtcbiAgICAgICAgY29uc3QgaCA9IGEuc3BsaXQoXCIsIFwiKVswXS5zcGxpdChcIjogXCIpWzFdLCBnID0gVChoKTtcbiAgICAgICAgdSh7IGR1cmF0aW9uOiBnLCByYXRpbzogUCB9KSwgKF8gPT09IDAgfHwgXyA+IGcpICYmIChfID0gZywgVSA9ICEwKTtcbiAgICAgIH0gZWxzZSBpZiAoVSAmJiBhLnN0YXJ0c1dpdGgoXCIgICAgU3RyZWFtXCIpKSB7XG4gICAgICAgIGNvbnN0IGggPSBhLm1hdGNoKC8oW1xcZC5dKykgZnBzLyk7XG4gICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgY29uc3QgZyA9IHBhcnNlRmxvYXQoaFsxXSk7XG4gICAgICAgICAgRyA9IF8gKiBnO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBHID0gMDtcbiAgICAgICAgVSA9ICExO1xuICAgICAgfSBlbHNlIGlmIChhLnN0YXJ0c1dpdGgoXCJmcmFtZVwiKSB8fCBhLnN0YXJ0c1dpdGgoXCJzaXplXCIpKSB7XG4gICAgICAgIGNvbnN0IGggPSBhLnNwbGl0KFwidGltZT1cIilbMV0uc3BsaXQoXCIgXCIpWzBdLCBnID0gVChoKSwgdCA9IGEubWF0Y2goL2ZyYW1lPVxccyooXFxkKykvKTtcbiAgICAgICAgaWYgKEcgJiYgdCkge1xuICAgICAgICAgIGNvbnN0IGUgPSBwYXJzZUZsb2F0KHRbMV0pO1xuICAgICAgICAgIFAgPSBNYXRoLm1pbihlIC8gRywgMSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIFAgPSBnIC8gXztcbiAgICAgICAgdSh7IHJhdGlvOiBQLCB0aW1lOiBnIH0pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGEuc3RhcnRzV2l0aChcInZpZGVvOlwiKSAmJiAodSh7IHJhdGlvOiAxIH0pLCBfID0gMCk7XG4gIH0sIEQgPSAoeyB0eXBlOiBhLCBtZXNzYWdlOiB1IH0pID0+IHtcbiAgICBPKGEsIHUpLCBrKHUsIE4pLCBMKHUpO1xuICB9LCBCID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChPKFwiaW5mb1wiLCBcImxvYWQgZmZtcGVnLWNvcmVcIiksIGwgPT09IG51bGwpIHtcbiAgICAgIE8oXCJpbmZvXCIsIFwibG9hZGluZyBmZm1wZWctY29yZVwiKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3JlYXRlRkZtcGVnQ29yZTogYSxcbiAgICAgICAgY29yZVBhdGg6IHUsXG4gICAgICAgIHdvcmtlclBhdGg6IGgsXG4gICAgICAgIHdhc21QYXRoOiBnXG4gICAgICB9ID0gYXdhaXQgTWUoYyk7XG4gICAgICBsID0gYXdhaXQgYSh7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEFzc2lnbiBtYWluU2NyaXB0VXJsT3JCbG9iIGZpeGVzIGNocm9tZSBleHRlbnNpb24gd2ViIHdvcmtlciBpc3N1ZVxuICAgICAgICAgKiBhcyB0aGVyZSBpcyBubyBkb2N1bWVudC5jdXJyZW50U2NyaXB0IGluIHRoZSBjb250ZXh0IG9mIGNvbnRlbnRfc2NyaXB0c1xuICAgICAgICAgKi9cbiAgICAgICAgbWFpblNjcmlwdFVybE9yQmxvYjogdSxcbiAgICAgICAgcHJpbnRFcnI6ICh0KSA9PiBEKHsgdHlwZTogXCJmZmVyclwiLCBtZXNzYWdlOiB0IH0pLFxuICAgICAgICBwcmludDogKHQpID0+IEQoeyB0eXBlOiBcImZmb3V0XCIsIG1lc3NhZ2U6IHQgfSksXG4gICAgICAgIC8qXG4gICAgICAgICAqIGxvY2F0ZUZpbGUgb3ZlcnJpZGVzIHBhdGhzIG9mIGZpbGVzIHRoYXQgaXMgbG9hZGVkIGJ5IG1haW4gc2NyaXB0IChmZm1wZWctY29yZS5qcykuXG4gICAgICAgICAqIEl0IGlzIGNyaXRpY2FsIGZvciBicm93c2VyIGVudmlyb25tZW50IGFuZCB3ZSBvdmVycmlkZSBib3RoIHdhc20gYW5kIHdvcmtlciBwYXRoc1xuICAgICAgICAgKiBhcyB3ZSBhcmUgdXNpbmcgYmxvYiBVUkwgaW5zdGVhZCBvZiBvcmlnaW5hbCBVUkwgdG8gYXZvaWQgY3Jvc3Mgb3JpZ2luIGlzc3Vlcy5cbiAgICAgICAgICovXG4gICAgICAgIGxvY2F0ZUZpbGU6ICh0LCBlKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIiB8fCB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPCBcInVcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBnIDwgXCJ1XCIgJiYgdC5lbmRzV2l0aChcImZmbXBlZy1jb3JlLndhc21cIikpXG4gICAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoIDwgXCJ1XCIgJiYgdC5lbmRzV2l0aChcImZmbXBlZy1jb3JlLndvcmtlci5qc1wiKSlcbiAgICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlICsgdDtcbiAgICAgICAgfVxuICAgICAgfSksIGogPSBsLmN3cmFwKGMubWFpbk5hbWUgfHwgXCJwcm94eV9tYWluXCIsIFwibnVtYmVyXCIsIFtcIm51bWJlclwiLCBcIm51bWJlclwiXSksIE8oXCJpbmZvXCIsIFwiZmZtcGVnLWNvcmUgbG9hZGVkXCIpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgRXJyb3IoXCJmZm1wZWcud2FzbSB3YXMgbG9hZGVkLCB5b3Ugc2hvdWxkIG5vdCBsb2FkIGl0IGFnYWluLCB1c2UgZmZtcGVnLmlzTG9hZGVkKCkgdG8gY2hlY2sgbmV4dCB0aW1lLlwiKTtcbiAgfSwgTSA9ICgpID0+IGwgIT09IG51bGwsICQgPSAoLi4uYSkgPT4ge1xuICAgIGlmIChPKFwiaW5mb1wiLCBgcnVuIGZmbXBlZyBjb21tYW5kOiAke2Euam9pbihcIiBcIil9YCksIGwgPT09IG51bGwpXG4gICAgICB0aHJvdyBKO1xuICAgIGlmICh2KVxuICAgICAgdGhyb3cgRXJyb3IoXCJmZm1wZWcud2FzbSBjYW4gb25seSBydW4gb25lIGNvbW1hbmQgYXQgYSB0aW1lXCIpO1xuICAgIHJldHVybiB2ID0gITAsIG5ldyBQcm9taXNlKCh1LCBoKSA9PiB7XG4gICAgICBjb25zdCBnID0gWy4uLk5lLCAuLi5hXS5maWx0ZXIoKHQpID0+IHQubGVuZ3RoICE9PSAwKTtcbiAgICAgIHkgPSB1LCBtID0gaCwgaiguLi5VZShsLCBnKSk7XG4gICAgfSk7XG4gIH0sIFkgPSAoYSwgLi4udSkgPT4ge1xuICAgIGlmIChPKFwiaW5mb1wiLCBgcnVuIEZTLiR7YX0gJHt1Lm1hcCgoaCkgPT4gdHlwZW9mIGggPT0gXCJzdHJpbmdcIiA/IGggOiBgPCR7aC5sZW5ndGh9IGJ5dGVzIGJpbmFyeSBmaWxlPmApLmpvaW4oXCIgXCIpfWApLCBsID09PSBudWxsKVxuICAgICAgdGhyb3cgSjtcbiAgICB7XG4gICAgICBsZXQgaCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBoID0gbC5GU1thXSguLi51KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB0aHJvdyBFcnJvcihhID09PSBcInJlYWRkaXJcIiA/IGBmZm1wZWcuRlMoJ3JlYWRkaXInLCAnJHt1WzBdfScpIGVycm9yLiBDaGVjayBpZiB0aGUgcGF0aCBleGlzdHMsIGV4OiBmZm1wZWcuRlMoJ3JlYWRkaXInLCAnLycpYCA6IGEgPT09IFwicmVhZEZpbGVcIiA/IGBmZm1wZWcuRlMoJ3JlYWRGaWxlJywgJyR7dVswXX0nKSBlcnJvci4gQ2hlY2sgaWYgdGhlIHBhdGggZXhpc3RzYCA6IFwiT29wcywgc29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gRlMgb3BlcmF0aW9uLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoO1xuICAgIH1cbiAgfSwgSSA9ICgpID0+IHtcbiAgICBpZiAobCA9PT0gbnVsbClcbiAgICAgIHRocm93IEo7XG4gICAgbSAmJiBtKFwiZmZtcGVnIGhhcyBleGl0ZWRcIiksIHYgPSAhMTtcbiAgICB0cnkge1xuICAgICAgbC5leGl0KDEpO1xuICAgIH0gY2F0Y2ggKGEpIHtcbiAgICAgIE8oYS5tZXNzYWdlKSwgbSAmJiBtKGEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBsID0gbnVsbCwgaiA9IG51bGwsIHkgPSBudWxsLCBtID0gbnVsbDtcbiAgICB9XG4gIH0sIFYgPSAoYSkgPT4ge1xuICAgIE4gPSBhO1xuICB9LCBxID0gKGEpID0+IHtcbiAgICB3ID0gYTtcbiAgfSwgeCA9IChhKSA9PiB7XG4gICAgQyA9IGE7XG4gIH07XG4gIHJldHVybiBPKFwiaW5mb1wiLCBgdXNlIGZmbXBlZy53YXNtIHYke0llfWApLCB7XG4gICAgc2V0UHJvZ3Jlc3M6IFYsXG4gICAgc2V0TG9nZ2VyOiBxLFxuICAgIHNldExvZ2dpbmc6IHgsXG4gICAgbG9hZDogQixcbiAgICBpc0xvYWRlZDogTSxcbiAgICBydW46ICQsXG4gICAgZXhpdDogSSxcbiAgICBGUzogWVxuICB9O1xufTtcbmNvbnN0IEJlID0gV2UsIHsgZmV0Y2hGaWxlOiB6ZSB9ID0gZWU7XG52YXIgdGUgPSB7XG4gIC8qXG4gICAqIENyZWF0ZSBmZm1wZWcgaW5zdGFuY2UuXG4gICAqIEVhY2ggZmZtcGVnIGluc3RhbmNlIG93bnMgYW4gaXNvbGF0ZWQgTUVNRlMgYW5kIHdvcmtzXG4gICAqIGluZGVwZW5kZW50bHkuXG4gICAqXG4gICAqIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgZmZtcGVnID0gY3JlYXRlRkZtcGVnKHtcbiAgICogIGxvZzogdHJ1ZSxcbiAgICogIGxvZ2dlcjogKCkgPT4ge30sXG4gICAqICBwcm9ncmVzczogKCkgPT4ge30sXG4gICAqICBjb3JlUGF0aDogJycsXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBGb3IgdGhlIHVzYWdlIG9mIHRoZXNlIGZvdXIgYXJndW1lbnRzLCBjaGVjayBjb25maWcuanNcbiAgICpcbiAgICovXG4gIGNyZWF0ZUZGbXBlZzogQmUsXG4gIC8qXG4gICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgZmV0Y2hpbmcgZmlsZXMgZnJvbSB2YXJpb3VzIHJlc291cmNlLlxuICAgKiBTb21ldGltZXMgdGhlIHZpZGVvL2F1ZGlvIGZpbGUgeW91IHdhbnQgdG8gcHJvY2VzcyBtYXkgbG9jYXRlZFxuICAgKiBpbiBhIHJlbW90ZSBVUkwgYW5kIHNvbWV3aGVyZSBpbiB5b3VyIGxvY2FsIGZpbGUgc3lzdGVtLlxuICAgKlxuICAgKiBUaGlzIGhlbHBlciBmdW5jdGlvbiBoZWxwcyB5b3UgdG8gZmV0Y2ggdG8gZmlsZSBhbmQgcmV0dXJuIGFuXG4gICAqIFVpbnQ4QXJyYXkgdmFyaWFibGUgZm9yIGZmbXBlZy53YXNtIHRvIGNvbnN1bWUuXG4gICAqXG4gICAqL1xuICBmZXRjaEZpbGU6IHplXG59O1xuY29uc3QgWWUgPSAvKiBAX19QVVJFX18gKi8gb2UodGUpLCBxZSA9IC8qIEBfX1BVUkVfXyAqLyByZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZGVmYXVsdDogWWVcbn0sIFt0ZV0pO1xuZXhwb3J0IHtcbiAgcWUgYXMgaVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-audio-voice-recorder/dist/index-1c988149.js\n"));

/***/ })

}]);