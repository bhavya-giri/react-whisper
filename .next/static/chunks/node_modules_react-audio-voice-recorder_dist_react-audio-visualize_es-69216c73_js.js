"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_react-audio-voice-recorder_dist_react-audio-visualize_es-69216c73_js"],{

/***/ "./node_modules/react-audio-voice-recorder/dist/react-audio-visualize.es-69216c73.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/react-audio-voice-recorder/dist/react-audio-visualize.es-69216c73.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioVisualizer: function() { return /* binding */ br; },\n/* harmony export */   LiveAudioVisualizer: function() { return /* binding */ Sr; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar ne = { exports: {} }, z = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar je;\nfunction dr() {\n  if (je)\n    return z;\n  je = 1;\n  var y = react__WEBPACK_IMPORTED_MODULE_0__, m = Symbol.for(\"react.element\"), _ = Symbol.for(\"react.fragment\"), b = Object.prototype.hasOwnProperty, h = y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, w = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function k(i, s, g) {\n    var o, a = {}, d = null, E = null;\n    g !== void 0 && (d = \"\" + g), s.key !== void 0 && (d = \"\" + s.key), s.ref !== void 0 && (E = s.ref);\n    for (o in s)\n      b.call(s, o) && !w.hasOwnProperty(o) && (a[o] = s[o]);\n    if (i && i.defaultProps)\n      for (o in s = i.defaultProps, s)\n        a[o] === void 0 && (a[o] = s[o]);\n    return { $$typeof: m, type: i, key: d, ref: E, props: a, _owner: h.current };\n  }\n  return z.Fragment = _, z.jsx = k, z.jsxs = k, z;\n}\nvar q = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Pe;\nfunction mr() {\n  return Pe || (Pe = 1,  true && function() {\n    var y = react__WEBPACK_IMPORTED_MODULE_0__, m = Symbol.for(\"react.element\"), _ = Symbol.for(\"react.portal\"), b = Symbol.for(\"react.fragment\"), h = Symbol.for(\"react.strict_mode\"), w = Symbol.for(\"react.profiler\"), k = Symbol.for(\"react.provider\"), i = Symbol.for(\"react.context\"), s = Symbol.for(\"react.forward_ref\"), g = Symbol.for(\"react.suspense\"), o = Symbol.for(\"react.suspense_list\"), a = Symbol.for(\"react.memo\"), d = Symbol.for(\"react.lazy\"), E = Symbol.for(\"react.offscreen\"), C = Symbol.iterator, T = \"@@iterator\";\n    function D(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var r = C && e[C] || e[T];\n      return typeof r == \"function\" ? r : null;\n    }\n    var l = y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function f(e) {\n      {\n        for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)\n          t[n - 1] = arguments[n];\n        j(\"error\", e, t);\n      }\n    }\n    function j(e, r, t) {\n      {\n        var n = l.ReactDebugCurrentFrame, p = n.getStackAddendum();\n        p !== \"\" && (r += \"%s\", t = t.concat([p]));\n        var v = t.map(function(u) {\n          return String(u);\n        });\n        v.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, v);\n      }\n    }\n    var xe = !1, Fe = !1, Ne = !1, Ae = !1, Ie = !1, oe;\n    oe = Symbol.for(\"react.module.reference\");\n    function Le(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === b || e === w || Ie || e === h || e === g || e === o || Ae || e === E || xe || Fe || Ne || typeof e == \"object\" && e !== null && (e.$$typeof === d || e.$$typeof === a || e.$$typeof === k || e.$$typeof === i || e.$$typeof === s || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      e.$$typeof === oe || e.getModuleId !== void 0));\n    }\n    function ze(e, r, t) {\n      var n = e.displayName;\n      if (n)\n        return n;\n      var p = r.displayName || r.name || \"\";\n      return p !== \"\" ? t + \"(\" + p + \")\" : t;\n    }\n    function ae(e) {\n      return e.displayName || \"Context\";\n    }\n    function $(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && f(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case b:\n          return \"Fragment\";\n        case _:\n          return \"Portal\";\n        case w:\n          return \"Profiler\";\n        case h:\n          return \"StrictMode\";\n        case g:\n          return \"Suspense\";\n        case o:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case i:\n            var r = e;\n            return ae(r) + \".Consumer\";\n          case k:\n            var t = e;\n            return ae(t._context) + \".Provider\";\n          case s:\n            return ze(e, e.render, \"ForwardRef\");\n          case a:\n            var n = e.displayName || null;\n            return n !== null ? n : $(e.type) || \"Memo\";\n          case d: {\n            var p = e, v = p._payload, u = p._init;\n            try {\n              return $(u(v));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var F = Object.assign, I = 0, ie, ce, le, se, ue, fe, pe;\n    function ye() {\n    }\n    ye.__reactDisabledLog = !0;\n    function We() {\n      {\n        if (I === 0) {\n          ie = console.log, ce = console.info, le = console.warn, se = console.error, ue = console.group, fe = console.groupCollapsed, pe = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: ye,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        I++;\n      }\n    }\n    function Me() {\n      {\n        if (I--, I === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: F({}, e, {\n              value: ie\n            }),\n            info: F({}, e, {\n              value: ce\n            }),\n            warn: F({}, e, {\n              value: le\n            }),\n            error: F({}, e, {\n              value: se\n            }),\n            group: F({}, e, {\n              value: ue\n            }),\n            groupCollapsed: F({}, e, {\n              value: fe\n            }),\n            groupEnd: F({}, e, {\n              value: pe\n            })\n          });\n        }\n        I < 0 && f(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var X = l.ReactCurrentDispatcher, J;\n    function W(e, r, t) {\n      {\n        if (J === void 0)\n          try {\n            throw Error();\n          } catch (p) {\n            var n = p.stack.trim().match(/\\n( *(at )?)/);\n            J = n && n[1] || \"\";\n          }\n        return `\n` + J + e;\n      }\n    }\n    var K = !1, M;\n    {\n      var Ue = typeof WeakMap == \"function\" ? WeakMap : Map;\n      M = new Ue();\n    }\n    function de(e, r) {\n      if (!e || K)\n        return \"\";\n      {\n        var t = M.get(e);\n        if (t !== void 0)\n          return t;\n      }\n      var n;\n      K = !0;\n      var p = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var v;\n      v = X.current, X.current = null, We();\n      try {\n        if (r) {\n          var u = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(u.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(u, []);\n            } catch (x) {\n              n = x;\n            }\n            Reflect.construct(e, [], u);\n          } else {\n            try {\n              u.call();\n            } catch (x) {\n              n = x;\n            }\n            e.call(u.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            n = x;\n          }\n          e();\n        }\n      } catch (x) {\n        if (x && n && typeof x.stack == \"string\") {\n          for (var c = x.stack.split(`\n`), O = n.stack.split(`\n`), S = c.length - 1, R = O.length - 1; S >= 1 && R >= 0 && c[S] !== O[R]; )\n            R--;\n          for (; S >= 1 && R >= 0; S--, R--)\n            if (c[S] !== O[R]) {\n              if (S !== 1 || R !== 1)\n                do\n                  if (S--, R--, R < 0 || c[S] !== O[R]) {\n                    var P = `\n` + c[S].replace(\" at new \", \" at \");\n                    return e.displayName && P.includes(\"<anonymous>\") && (P = P.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && M.set(e, P), P;\n                  }\n                while (S >= 1 && R >= 0);\n              break;\n            }\n        }\n      } finally {\n        K = !1, X.current = v, Me(), Error.prepareStackTrace = p;\n      }\n      var A = e ? e.displayName || e.name : \"\", Oe = A ? W(A) : \"\";\n      return typeof e == \"function\" && M.set(e, Oe), Oe;\n    }\n    function Be(e, r, t) {\n      return de(e, !1);\n    }\n    function Ve(e) {\n      var r = e.prototype;\n      return !!(r && r.isReactComponent);\n    }\n    function U(e, r, t) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return de(e, Ve(e));\n      if (typeof e == \"string\")\n        return W(e);\n      switch (e) {\n        case g:\n          return W(\"Suspense\");\n        case o:\n          return W(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case s:\n            return Be(e.render);\n          case a:\n            return U(e.type, r, t);\n          case d: {\n            var n = e, p = n._payload, v = n._init;\n            try {\n              return U(v(p), r, t);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var B = Object.prototype.hasOwnProperty, me = {}, ge = l.ReactDebugCurrentFrame;\n    function V(e) {\n      if (e) {\n        var r = e._owner, t = U(e.type, e._source, r ? r.type : null);\n        ge.setExtraStackFrame(t);\n      } else\n        ge.setExtraStackFrame(null);\n    }\n    function qe(e, r, t, n, p) {\n      {\n        var v = Function.call.bind(B);\n        for (var u in e)\n          if (v(e, u)) {\n            var c = void 0;\n            try {\n              if (typeof e[u] != \"function\") {\n                var O = Error((n || \"React class\") + \": \" + t + \" type `\" + u + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[u] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw O.name = \"Invariant Violation\", O;\n              }\n              c = e[u](r, u, n, t, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (S) {\n              c = S;\n            }\n            c && !(c instanceof Error) && (V(p), f(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", n || \"React class\", t, u, typeof c), V(null)), c instanceof Error && !(c.message in me) && (me[c.message] = !0, V(p), f(\"Failed %s type: %s\", t, c.message), V(null));\n          }\n      }\n    }\n    var Ye = Array.isArray;\n    function Q(e) {\n      return Ye(e);\n    }\n    function He(e) {\n      {\n        var r = typeof Symbol == \"function\" && Symbol.toStringTag, t = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return t;\n      }\n    }\n    function Xe(e) {\n      try {\n        return ve(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function ve(e) {\n      return \"\" + e;\n    }\n    function he(e) {\n      if (Xe(e))\n        return f(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", He(e)), ve(e);\n    }\n    var L = l.ReactCurrentOwner, Je = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, be, we, Z;\n    Z = {};\n    function Ke(e) {\n      if (B.call(e, \"ref\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function Qe(e) {\n      if (B.call(e, \"key\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function Ze(e, r) {\n      if (typeof e.ref == \"string\" && L.current && r && L.current.stateNode !== r) {\n        var t = $(L.current.type);\n        Z[t] || (f('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(L.current.type), e.ref), Z[t] = !0);\n      }\n    }\n    function Ge(e, r) {\n      {\n        var t = function() {\n          be || (be = !0, f(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    function er(e, r) {\n      {\n        var t = function() {\n          we || (we = !0, f(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    var rr = function(e, r, t, n, p, v, u) {\n      var c = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: m,\n        // Built-in properties that belong on the element\n        type: e,\n        key: r,\n        ref: t,\n        props: u,\n        // Record the component responsible for creating this element.\n        _owner: v\n      };\n      return c._store = {}, Object.defineProperty(c._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(c, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: n\n      }), Object.defineProperty(c, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: p\n      }), Object.freeze && (Object.freeze(c.props), Object.freeze(c)), c;\n    };\n    function tr(e, r, t, n, p) {\n      {\n        var v, u = {}, c = null, O = null;\n        t !== void 0 && (he(t), c = \"\" + t), Qe(r) && (he(r.key), c = \"\" + r.key), Ke(r) && (O = r.ref, Ze(r, p));\n        for (v in r)\n          B.call(r, v) && !Je.hasOwnProperty(v) && (u[v] = r[v]);\n        if (e && e.defaultProps) {\n          var S = e.defaultProps;\n          for (v in S)\n            u[v] === void 0 && (u[v] = S[v]);\n        }\n        if (c || O) {\n          var R = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          c && Ge(u, R), O && er(u, R);\n        }\n        return rr(e, c, O, p, n, L.current, u);\n      }\n    }\n    var G = l.ReactCurrentOwner, Se = l.ReactDebugCurrentFrame;\n    function N(e) {\n      if (e) {\n        var r = e._owner, t = U(e.type, e._source, r ? r.type : null);\n        Se.setExtraStackFrame(t);\n      } else\n        Se.setExtraStackFrame(null);\n    }\n    var ee;\n    ee = !1;\n    function re(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === m;\n    }\n    function ke() {\n      {\n        if (G.current) {\n          var e = $(G.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function nr(e) {\n      {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), t = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + t + \".\";\n        }\n        return \"\";\n      }\n    }\n    var Re = {};\n    function or(e) {\n      {\n        var r = ke();\n        if (!r) {\n          var t = typeof e == \"string\" ? e : e.displayName || e.name;\n          t && (r = `\n\nCheck the top-level render call using <` + t + \">.\");\n        }\n        return r;\n      }\n    }\n    function _e(e, r) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var t = or(r);\n        if (Re[t])\n          return;\n        Re[t] = !0;\n        var n = \"\";\n        e && e._owner && e._owner !== G.current && (n = \" It was passed a child from \" + $(e._owner.type) + \".\"), N(e), f('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, n), N(null);\n      }\n    }\n    function Ee(e, r) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (Q(e))\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];\n            re(n) && _e(n, r);\n          }\n        else if (re(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var p = D(e);\n          if (typeof p == \"function\" && p !== e.entries)\n            for (var v = p.call(e), u; !(u = v.next()).done; )\n              re(u.value) && _e(u.value, r);\n        }\n      }\n    }\n    function ar(e) {\n      {\n        var r = e.type;\n        if (r == null || typeof r == \"string\")\n          return;\n        var t;\n        if (typeof r == \"function\")\n          t = r.propTypes;\n        else if (typeof r == \"object\" && (r.$$typeof === s || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        r.$$typeof === a))\n          t = r.propTypes;\n        else\n          return;\n        if (t) {\n          var n = $(r);\n          qe(t, e.props, \"prop\", n, e);\n        } else if (r.PropTypes !== void 0 && !ee) {\n          ee = !0;\n          var p = $(r);\n          f(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", p || \"Unknown\");\n        }\n        typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && f(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function ir(e) {\n      {\n        for (var r = Object.keys(e.props), t = 0; t < r.length; t++) {\n          var n = r[t];\n          if (n !== \"children\" && n !== \"key\") {\n            N(e), f(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", n), N(null);\n            break;\n          }\n        }\n        e.ref !== null && (N(e), f(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), N(null));\n      }\n    }\n    function Ce(e, r, t, n, p, v) {\n      {\n        var u = Le(e);\n        if (!u) {\n          var c = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (c += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var O = nr(p);\n          O ? c += O : c += ke();\n          var S;\n          e === null ? S = \"null\" : Q(e) ? S = \"array\" : e !== void 0 && e.$$typeof === m ? (S = \"<\" + ($(e.type) || \"Unknown\") + \" />\", c = \" Did you accidentally export a JSX literal instead of a component?\") : S = typeof e, f(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", S, c);\n        }\n        var R = tr(e, r, t, p, v);\n        if (R == null)\n          return R;\n        if (u) {\n          var P = r.children;\n          if (P !== void 0)\n            if (n)\n              if (Q(P)) {\n                for (var A = 0; A < P.length; A++)\n                  Ee(P[A], e);\n                Object.freeze && Object.freeze(P);\n              } else\n                f(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Ee(P, e);\n        }\n        return e === b ? ir(R) : ar(R), R;\n      }\n    }\n    function cr(e, r, t) {\n      return Ce(e, r, t, !0);\n    }\n    function lr(e, r, t) {\n      return Ce(e, r, t, !1);\n    }\n    var sr = lr, ur = cr;\n    q.Fragment = b, q.jsx = sr, q.jsxs = ur;\n  }()), q;\n}\n false ? 0 : ne.exports = mr();\nvar $e = ne.exports;\nconst gr = (y, m, _, b) => {\n  let h = m / (_ + b), w = Math.floor(y.length / h);\n  h > y.length && (h = y.length, w = 1);\n  const k = [];\n  for (let i = 0; i < h; i++) {\n    let s = 0;\n    for (let g = 0; g < w && i * w + g < y.length; g++)\n      s += y[i * w + g];\n    k.push(s / w);\n  }\n  return k;\n}, vr = (y, m, _, b, h, w) => {\n  const k = m.height / 2, i = m.getContext(\"2d\");\n  i && (i.clearRect(0, 0, m.width, m.height), h !== \"transparent\" && (i.fillStyle = h, i.fillRect(0, 0, m.width, m.height)), y.forEach((s, g) => {\n    i.fillStyle = w;\n    const o = g * (_ + b), a = k - s / 2, d = _, E = s || 1;\n    i.beginPath(), i.roundRect ? (i.roundRect(o, a, d, E, 50), i.fill()) : i.fillRect(o, a, d, E);\n  }));\n}, Sr = ({\n  mediaRecorder: y,\n  width: m = \"100%\",\n  height: _ = \"100%\",\n  barWidth: b = 2,\n  gap: h = 1,\n  backgroundColor: w = \"transparent\",\n  barColor: k = \"rgb(160, 198, 255)\",\n  fftSize: i = 1024,\n  maxDecibels: s = -10,\n  minDecibels: g = -90,\n  smoothingTimeConstant: o = 0.4\n}) => {\n  const [a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new AudioContext()), [d, E] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), C = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!y.stream)\n      return;\n    const l = a.createAnalyser();\n    E(l), l.fftSize = i, l.minDecibels = g, l.maxDecibels = s, l.smoothingTimeConstant = o, a.createMediaStreamSource(y.stream).connect(l);\n  }, [y.stream]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    d && y.state === \"recording\" && T();\n  }, [d, y.state]);\n  const T = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (!d)\n      return;\n    const l = new Uint8Array(d == null ? void 0 : d.frequencyBinCount);\n    y.state === \"recording\" ? (d == null || d.getByteFrequencyData(l), D(l), requestAnimationFrame(T)) : y.state === \"paused\" ? D(l) : y.state === \"inactive\" && a.state !== \"closed\" && a.close();\n  }, [d, a.state]), D = (l) => {\n    if (!C.current)\n      return;\n    const f = gr(\n      l,\n      C.current.width,\n      b,\n      h\n    );\n    vr(\n      f,\n      C.current,\n      b,\n      h,\n      w,\n      k\n    );\n  };\n  return /* @__PURE__ */ $e.jsx(\n    \"canvas\",\n    {\n      ref: C,\n      width: m,\n      height: _,\n      style: {\n        aspectRatio: \"unset\"\n      }\n    }\n  );\n}, hr = (y, m, _, b, h) => {\n  const w = y.getChannelData(0), k = _ / (b + h), i = Math.floor(w.length / k), s = m / 2;\n  let g = [], o = 0;\n  for (let a = 0; a < k; a++) {\n    const d = [];\n    let E = 0;\n    const C = [];\n    let T = 0;\n    for (let f = 0; f < i && a * i + f < y.length; f++) {\n      const j = w[a * i + f];\n      j <= 0 && (d.push(j), E++), j > 0 && (C.push(j), T++);\n    }\n    const D = d.reduce((f, j) => f + j, 0) / E, l = { max: C.reduce((f, j) => f + j, 0) / T, min: D };\n    l.max > o && (o = l.max), Math.abs(l.min) > o && (o = Math.abs(l.min)), g.push(l);\n  }\n  if (s * 0.8 > o * s) {\n    const a = s * 0.8 / o;\n    g = g.map((d) => ({\n      max: d.max * a,\n      min: d.min * a\n    }));\n  }\n  return g;\n}, te = (y, m, _, b, h, w, k, i = 0, s = 1) => {\n  const g = m.height / 2, o = m.getContext(\"2d\");\n  if (!o)\n    return;\n  o.clearRect(0, 0, m.width, m.height), h !== \"transparent\" && (o.fillStyle = h, o.fillRect(0, 0, m.width, m.height));\n  const a = (i || 0) / s;\n  y.forEach((d, E) => {\n    const C = E / y.length, T = a > C;\n    o.fillStyle = T && k ? k : w;\n    const D = E * (_ + b), l = g + d.min, f = _, j = g + d.max - l;\n    o.beginPath(), o.roundRect ? (o.roundRect(D, l, f, j, 50), o.fill()) : o.fillRect(D, l, f, j);\n  });\n}, br = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({\n    blob: y,\n    width: m,\n    height: _,\n    barWidth: b = 2,\n    gap: h = 1,\n    currentTime: w,\n    style: k,\n    backgroundColor: i = \"transparent\",\n    barColor: s = \"rgb(184, 184, 184)\",\n    barPlayedColor: g = \"rgb(160, 198, 255)\"\n  }, o) => {\n    const a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [d, E] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), [C, T] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(\n      o,\n      () => a.current,\n      []\n    ), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      (async () => {\n        if (!a.current)\n          return;\n        if (!y) {\n          const l = Array.from({ length: 100 }, () => ({\n            max: 0,\n            min: 0\n          }));\n          te(\n            l,\n            a.current,\n            b,\n            h,\n            i,\n            s,\n            g\n          );\n          return;\n        }\n        const D = await y.arrayBuffer();\n        await new AudioContext().decodeAudioData(D, (l) => {\n          if (!a.current)\n            return;\n          T(l.duration);\n          const f = hr(\n            l,\n            _,\n            m,\n            b,\n            h\n          );\n          E(f), te(\n            f,\n            a.current,\n            b,\n            h,\n            i,\n            s,\n            g\n          );\n        });\n      })();\n    }, [y, a.current]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      a.current && te(\n        d,\n        a.current,\n        b,\n        h,\n        i,\n        s,\n        g,\n        w,\n        C\n      );\n    }, [w, C]), /* @__PURE__ */ $e.jsx(\n      \"canvas\",\n      {\n        ref: a,\n        width: m,\n        height: _,\n        style: {\n          ...k\n        }\n      }\n    );\n  }\n);\nbr.displayName = \"AudioVisualizer\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtYXVkaW8tdm9pY2UtcmVjb3JkZXIvZGlzdC9yZWFjdC1hdWRpby12aXN1YWxpemUuZXMtNjkyMTZjNzMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdJO0FBQ3hJLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBRSw0TEFBNEw7QUFDeE07QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFxQztBQUM3RCxZQUFZLGtDQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLE9BQU87QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYixnQ0FBZ0M7QUFDaEM7QUFDQSxhQUFhO0FBQ2IsMEJBQTBCO0FBQzFCO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUNBQW1DO0FBQzNFO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxNQUFxQyxHQUFHLENBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjLCtDQUFDLHFDQUFxQywrQ0FBQyxRQUFRLDZDQUFFO0FBQy9ELEVBQUUsZ0RBQUM7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZUFBZSxnREFBQztBQUNuQjtBQUNBLEdBQUc7QUFDSCxZQUFZLGtEQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLE9BQU8saURBQUU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsNkNBQUUsaUJBQWlCLCtDQUFDLGVBQWUsK0NBQUM7QUFDbEQsV0FBVywwREFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0RBQUM7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSyxtQkFBbUIsZ0RBQUM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1hdWRpby12b2ljZS1yZWNvcmRlci9kaXN0L3JlYWN0LWF1ZGlvLXZpc3VhbGl6ZS5lcy02OTIxNmM3My5qcz9jNDlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZSwgeyB1c2VTdGF0ZSBhcyBZLCB1c2VSZWYgYXMgRGUsIHVzZUVmZmVjdCBhcyBILCB1c2VDYWxsYmFjayBhcyBmciwgZm9yd2FyZFJlZiBhcyBwciwgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB5ciB9IGZyb20gXCJyZWFjdFwiO1xudmFyIG5lID0geyBleHBvcnRzOiB7fSB9LCB6ID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgamU7XG5mdW5jdGlvbiBkcigpIHtcbiAgaWYgKGplKVxuICAgIHJldHVybiB6O1xuICBqZSA9IDE7XG4gIHZhciB5ID0gVGUsIG0gPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgXyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgYiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGggPSB5Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCB3ID0geyBrZXk6ICEwLCByZWY6ICEwLCBfX3NlbGY6ICEwLCBfX3NvdXJjZTogITAgfTtcbiAgZnVuY3Rpb24gayhpLCBzLCBnKSB7XG4gICAgdmFyIG8sIGEgPSB7fSwgZCA9IG51bGwsIEUgPSBudWxsO1xuICAgIGcgIT09IHZvaWQgMCAmJiAoZCA9IFwiXCIgKyBnKSwgcy5rZXkgIT09IHZvaWQgMCAmJiAoZCA9IFwiXCIgKyBzLmtleSksIHMucmVmICE9PSB2b2lkIDAgJiYgKEUgPSBzLnJlZik7XG4gICAgZm9yIChvIGluIHMpXG4gICAgICBiLmNhbGwocywgbykgJiYgIXcuaGFzT3duUHJvcGVydHkobykgJiYgKGFbb10gPSBzW29dKTtcbiAgICBpZiAoaSAmJiBpLmRlZmF1bHRQcm9wcylcbiAgICAgIGZvciAobyBpbiBzID0gaS5kZWZhdWx0UHJvcHMsIHMpXG4gICAgICAgIGFbb10gPT09IHZvaWQgMCAmJiAoYVtvXSA9IHNbb10pO1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiBtLCB0eXBlOiBpLCBrZXk6IGQsIHJlZjogRSwgcHJvcHM6IGEsIF9vd25lcjogaC5jdXJyZW50IH07XG4gIH1cbiAgcmV0dXJuIHouRnJhZ21lbnQgPSBfLCB6LmpzeCA9IGssIHouanN4cyA9IGssIHo7XG59XG52YXIgcSA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIFBlO1xuZnVuY3Rpb24gbXIoKSB7XG4gIHJldHVybiBQZSB8fCAoUGUgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHkgPSBUZSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBfID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgYiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgaCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgdyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgayA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgaSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBzID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBnID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBvID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIGEgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgZCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgQyA9IFN5bWJvbC5pdGVyYXRvciwgVCA9IFwiQEBpdGVyYXRvclwiO1xuICAgIGZ1bmN0aW9uIEQoZSkge1xuICAgICAgaWYgKGUgPT09IG51bGwgfHwgdHlwZW9mIGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgciA9IEMgJiYgZVtDXSB8fCBlW1RdO1xuICAgICAgcmV0dXJuIHR5cGVvZiByID09IFwiZnVuY3Rpb25cIiA/IHIgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgbCA9IHkuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gICAgZnVuY3Rpb24gZihlKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KHIgPiAxID8gciAtIDEgOiAwKSwgbiA9IDE7IG4gPCByOyBuKyspXG4gICAgICAgICAgdFtuIC0gMV0gPSBhcmd1bWVudHNbbl07XG4gICAgICAgIGooXCJlcnJvclwiLCBlLCB0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaihlLCByLCB0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBuID0gbC5SZWFjdERlYnVnQ3VycmVudEZyYW1lLCBwID0gbi5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgIHAgIT09IFwiXCIgJiYgKHIgKz0gXCIlc1wiLCB0ID0gdC5jb25jYXQoW3BdKSk7XG4gICAgICAgIHZhciB2ID0gdC5tYXAoZnVuY3Rpb24odSkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2LnVuc2hpZnQoXCJXYXJuaW5nOiBcIiArIHIpLCBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2VdLCBjb25zb2xlLCB2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHhlID0gITEsIEZlID0gITEsIE5lID0gITEsIEFlID0gITEsIEllID0gITEsIG9lO1xuICAgIG9lID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gICAgZnVuY3Rpb24gTGUoZSkge1xuICAgICAgcmV0dXJuICEhKHR5cGVvZiBlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiIHx8IGUgPT09IGIgfHwgZSA9PT0gdyB8fCBJZSB8fCBlID09PSBoIHx8IGUgPT09IGcgfHwgZSA9PT0gbyB8fCBBZSB8fCBlID09PSBFIHx8IHhlIHx8IEZlIHx8IE5lIHx8IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiAoZS4kJHR5cGVvZiA9PT0gZCB8fCBlLiQkdHlwZW9mID09PSBhIHx8IGUuJCR0eXBlb2YgPT09IGsgfHwgZS4kJHR5cGVvZiA9PT0gaSB8fCBlLiQkdHlwZW9mID09PSBzIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgICAgLy8gd2l0aC5cbiAgICAgIGUuJCR0eXBlb2YgPT09IG9lIHx8IGUuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6ZShlLCByLCB0KSB7XG4gICAgICB2YXIgbiA9IGUuZGlzcGxheU5hbWU7XG4gICAgICBpZiAobilcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB2YXIgcCA9IHIuZGlzcGxheU5hbWUgfHwgci5uYW1lIHx8IFwiXCI7XG4gICAgICByZXR1cm4gcCAhPT0gXCJcIiA/IHQgKyBcIihcIiArIHAgKyBcIilcIiA6IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFlKGUpIHtcbiAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiAkKGUpIHtcbiAgICAgIGlmIChlID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBlLnRhZyA9PSBcIm51bWJlclwiICYmIGYoXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKSwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBfOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIHc6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBoOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBnOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgbzpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIGk6XG4gICAgICAgICAgICB2YXIgciA9IGU7XG4gICAgICAgICAgICByZXR1cm4gYWUocikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgazpcbiAgICAgICAgICAgIHZhciB0ID0gZTtcbiAgICAgICAgICAgIHJldHVybiBhZSh0Ll9jb250ZXh0KSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBzOlxuICAgICAgICAgICAgcmV0dXJuIHplKGUsIGUucmVuZGVyLCBcIkZvcndhcmRSZWZcIik7XG4gICAgICAgICAgY2FzZSBhOlxuICAgICAgICAgICAgdmFyIG4gPSBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbiAhPT0gbnVsbCA/IG4gOiAkKGUudHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgY2FzZSBkOiB7XG4gICAgICAgICAgICB2YXIgcCA9IGUsIHYgPSBwLl9wYXlsb2FkLCB1ID0gcC5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiAkKHUodikpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBGID0gT2JqZWN0LmFzc2lnbiwgSSA9IDAsIGllLCBjZSwgbGUsIHNlLCB1ZSwgZmUsIHBlO1xuICAgIGZ1bmN0aW9uIHllKCkge1xuICAgIH1cbiAgICB5ZS5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICBmdW5jdGlvbiBXZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEkgPT09IDApIHtcbiAgICAgICAgICBpZSA9IGNvbnNvbGUubG9nLCBjZSA9IGNvbnNvbGUuaW5mbywgbGUgPSBjb25zb2xlLndhcm4sIHNlID0gY29uc29sZS5lcnJvciwgdWUgPSBjb25zb2xlLmdyb3VwLCBmZSA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIHBlID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHZhbHVlOiB5ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgaW5mbzogZSxcbiAgICAgICAgICAgIGxvZzogZSxcbiAgICAgICAgICAgIHdhcm46IGUsXG4gICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgIGdyb3VwOiBlLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGUsXG4gICAgICAgICAgICBncm91cEVuZDogZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gTWUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChJLS0sIEkgPT09IDApIHtcbiAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgbG9nOiBGKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBpZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmZvOiBGKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBjZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YXJuOiBGKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBsZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlcnJvcjogRih7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogc2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXA6IEYoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBGKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBmZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cEVuZDogRih7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogcGVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgSSA8IDAgJiYgZihcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBYID0gbC5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCBKO1xuICAgIGZ1bmN0aW9uIFcoZSwgciwgdCkge1xuICAgICAge1xuICAgICAgICBpZiAoSiA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHApIHtcbiAgICAgICAgICAgIHZhciBuID0gcC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgIEogPSBuICYmIG5bMV0gfHwgXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXG5gICsgSiArIGU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBLID0gITEsIE07XG4gICAge1xuICAgICAgdmFyIFVlID0gdHlwZW9mIFdlYWtNYXAgPT0gXCJmdW5jdGlvblwiID8gV2Vha01hcCA6IE1hcDtcbiAgICAgIE0gPSBuZXcgVWUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGUoZSwgcikge1xuICAgICAgaWYgKCFlIHx8IEspXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IE0uZ2V0KGUpO1xuICAgICAgICBpZiAodCAhPT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgICAgdmFyIG47XG4gICAgICBLID0gITA7XG4gICAgICB2YXIgcCA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgdjtcbiAgICAgIHYgPSBYLmN1cnJlbnQsIFguY3VycmVudCA9IG51bGwsIFdlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIHZhciB1ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdCh1LCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIG4gPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZSwgW10sIHUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB1LmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgbiA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLmNhbGwodS5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICBuID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGlmICh4ICYmIG4gJiYgdHlwZW9mIHguc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAodmFyIGMgPSB4LnN0YWNrLnNwbGl0KGBcbmApLCBPID0gbi5zdGFjay5zcGxpdChgXG5gKSwgUyA9IGMubGVuZ3RoIC0gMSwgUiA9IE8ubGVuZ3RoIC0gMTsgUyA+PSAxICYmIFIgPj0gMCAmJiBjW1NdICE9PSBPW1JdOyApXG4gICAgICAgICAgICBSLS07XG4gICAgICAgICAgZm9yICg7IFMgPj0gMSAmJiBSID49IDA7IFMtLSwgUi0tKVxuICAgICAgICAgICAgaWYgKGNbU10gIT09IE9bUl0pIHtcbiAgICAgICAgICAgICAgaWYgKFMgIT09IDEgfHwgUiAhPT0gMSlcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFMtLSwgUi0tLCBSIDwgMCB8fCBjW1NdICE9PSBPW1JdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBQID0gYFxuYCArIGNbU10ucmVwbGFjZShcIiBhdCBuZXcgXCIsIFwiIGF0IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgJiYgUC5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmIChQID0gUC5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZS5kaXNwbGF5TmFtZSkpLCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgTS5zZXQoZSwgUCksIFA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKFMgPj0gMSAmJiBSID49IDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgSyA9ICExLCBYLmN1cnJlbnQgPSB2LCBNZSgpLCBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHA7XG4gICAgICB9XG4gICAgICB2YXIgQSA9IGUgPyBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSA6IFwiXCIsIE9lID0gQSA/IFcoQSkgOiBcIlwiO1xuICAgICAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiAmJiBNLnNldChlLCBPZSksIE9lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCZShlLCByLCB0KSB7XG4gICAgICByZXR1cm4gZGUoZSwgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWZShlKSB7XG4gICAgICB2YXIgciA9IGUucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKHIgJiYgci5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVShlLCByLCB0KSB7XG4gICAgICBpZiAoZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBkZShlLCBWZShlKSk7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIFcoZSk7XG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSBnOlxuICAgICAgICAgIHJldHVybiBXKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgbzpcbiAgICAgICAgICByZXR1cm4gVyhcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgICByZXR1cm4gQmUoZS5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgYTpcbiAgICAgICAgICAgIHJldHVybiBVKGUudHlwZSwgciwgdCk7XG4gICAgICAgICAgY2FzZSBkOiB7XG4gICAgICAgICAgICB2YXIgbiA9IGUsIHAgPSBuLl9wYXlsb2FkLCB2ID0gbi5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBVKHYocCksIHIsIHQpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIEIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBtZSA9IHt9LCBnZSA9IGwuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBWKGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHZhciByID0gZS5fb3duZXIsIHQgPSBVKGUudHlwZSwgZS5fc291cmNlLCByID8gci50eXBlIDogbnVsbCk7XG4gICAgICAgIGdlLnNldEV4dHJhU3RhY2tGcmFtZSh0KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBnZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHFlKGUsIHIsIHQsIG4sIHApIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHYgPSBGdW5jdGlvbi5jYWxsLmJpbmQoQik7XG4gICAgICAgIGZvciAodmFyIHUgaW4gZSlcbiAgICAgICAgICBpZiAodihlLCB1KSkge1xuICAgICAgICAgICAgdmFyIGMgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGVbdV0gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIE8gPSBFcnJvcigobiB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IFwiICsgdCArIFwiIHR5cGUgYFwiICsgdSArIFwiYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgXCIgKyB0eXBlb2YgZVt1XSArIFwiYC5UaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC5cIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgTy5uYW1lID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCIsIE87XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYyA9IGVbdV0ociwgdSwgbiwgdCwgbnVsbCwgXCJTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKFMpIHtcbiAgICAgICAgICAgICAgYyA9IFM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjICYmICEoYyBpbnN0YW5jZW9mIEVycm9yKSAmJiAoVihwKSwgZihcIiVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiBZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciBjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kIHNoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS5cIiwgbiB8fCBcIlJlYWN0IGNsYXNzXCIsIHQsIHUsIHR5cGVvZiBjKSwgVihudWxsKSksIGMgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGMubWVzc2FnZSBpbiBtZSkgJiYgKG1lW2MubWVzc2FnZV0gPSAhMCwgVihwKSwgZihcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCB0LCBjLm1lc3NhZ2UpLCBWKG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBZZSA9IEFycmF5LmlzQXJyYXk7XG4gICAgZnVuY3Rpb24gUShlKSB7XG4gICAgICByZXR1cm4gWWUoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEhlKGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHIgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIHQgPSByICYmIGVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBlLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFhlKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB2ZShlKSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2ZShlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhlKGUpIHtcbiAgICAgIGlmIChYZShlKSlcbiAgICAgICAgcmV0dXJuIGYoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgSGUoZSkpLCB2ZShlKTtcbiAgICB9XG4gICAgdmFyIEwgPSBsLlJlYWN0Q3VycmVudE93bmVyLCBKZSA9IHtcbiAgICAgIGtleTogITAsXG4gICAgICByZWY6ICEwLFxuICAgICAgX19zZWxmOiAhMCxcbiAgICAgIF9fc291cmNlOiAhMFxuICAgIH0sIGJlLCB3ZSwgWjtcbiAgICBaID0ge307XG4gICAgZnVuY3Rpb24gS2UoZSkge1xuICAgICAgaWYgKEIuY2FsbChlLCBcInJlZlwiKSkge1xuICAgICAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgXCJyZWZcIikuZ2V0O1xuICAgICAgICBpZiAociAmJiByLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLnJlZiAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBRZShlKSB7XG4gICAgICBpZiAoQi5jYWxsKGUsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChyICYmIHIuaXNSZWFjdFdhcm5pbmcpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGUua2V5ICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFplKGUsIHIpIHtcbiAgICAgIGlmICh0eXBlb2YgZS5yZWYgPT0gXCJzdHJpbmdcIiAmJiBMLmN1cnJlbnQgJiYgciAmJiBMLmN1cnJlbnQuc3RhdGVOb2RlICE9PSByKSB7XG4gICAgICAgIHZhciB0ID0gJChMLmN1cnJlbnQudHlwZSk7XG4gICAgICAgIFpbdF0gfHwgKGYoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCAkKEwuY3VycmVudC50eXBlKSwgZS5yZWYpLCBaW3RdID0gITApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBHZShlLCByKSB7XG4gICAgICB7XG4gICAgICAgIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYmUgfHwgKGJlID0gITAsIGYoXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCByKSk7XG4gICAgICAgIH07XG4gICAgICAgIHQuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwia2V5XCIsIHtcbiAgICAgICAgICBnZXQ6IHQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXIoZSwgcikge1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHdlIHx8ICh3ZSA9ICEwLCBmKFwiJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgcikpO1xuICAgICAgICB9O1xuICAgICAgICB0LmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInJlZlwiLCB7XG4gICAgICAgICAgZ2V0OiB0LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByciA9IGZ1bmN0aW9uKGUsIHIsIHQsIG4sIHAsIHYsIHUpIHtcbiAgICAgIHZhciBjID0ge1xuICAgICAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAgICAgJCR0eXBlb2Y6IG0sXG4gICAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgdHlwZTogZSxcbiAgICAgICAga2V5OiByLFxuICAgICAgICByZWY6IHQsXG4gICAgICAgIHByb3BzOiB1LFxuICAgICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgICAgICBfb3duZXI6IHZcbiAgICAgIH07XG4gICAgICByZXR1cm4gYy5fc3RvcmUgPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGMuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAhMVxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLCBcIl9zZWxmXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IG5cbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYywgXCJfc291cmNlXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgdmFsdWU6IHBcbiAgICAgIH0pLCBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKGMucHJvcHMpLCBPYmplY3QuZnJlZXplKGMpKSwgYztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRyKGUsIHIsIHQsIG4sIHApIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHYsIHUgPSB7fSwgYyA9IG51bGwsIE8gPSBudWxsO1xuICAgICAgICB0ICE9PSB2b2lkIDAgJiYgKGhlKHQpLCBjID0gXCJcIiArIHQpLCBRZShyKSAmJiAoaGUoci5rZXkpLCBjID0gXCJcIiArIHIua2V5KSwgS2UocikgJiYgKE8gPSByLnJlZiwgWmUociwgcCkpO1xuICAgICAgICBmb3IgKHYgaW4gcilcbiAgICAgICAgICBCLmNhbGwociwgdikgJiYgIUplLmhhc093blByb3BlcnR5KHYpICYmICh1W3ZdID0gclt2XSk7XG4gICAgICAgIGlmIChlICYmIGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgdmFyIFMgPSBlLmRlZmF1bHRQcm9wcztcbiAgICAgICAgICBmb3IgKHYgaW4gUylcbiAgICAgICAgICAgIHVbdl0gPT09IHZvaWQgMCAmJiAodVt2XSA9IFNbdl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIHx8IE8pIHtcbiAgICAgICAgICB2YXIgUiA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lIHx8IFwiVW5rbm93blwiIDogZTtcbiAgICAgICAgICBjICYmIEdlKHUsIFIpLCBPICYmIGVyKHUsIFIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBycihlLCBjLCBPLCBwLCBuLCBMLmN1cnJlbnQsIHUpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgRyA9IGwuUmVhY3RDdXJyZW50T3duZXIsIFNlID0gbC5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIE4oZSkge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdmFyIHIgPSBlLl9vd25lciwgdCA9IFUoZS50eXBlLCBlLl9zb3VyY2UsIHIgPyByLnR5cGUgOiBudWxsKTtcbiAgICAgICAgU2Uuc2V0RXh0cmFTdGFja0ZyYW1lKHQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIFNlLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgdmFyIGVlO1xuICAgIGVlID0gITE7XG4gICAgZnVuY3Rpb24gcmUoZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBlLiQkdHlwZW9mID09PSBtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEcuY3VycmVudCkge1xuICAgICAgICAgIHZhciBlID0gJChHLmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgaWYgKGUpXG4gICAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBcXGBgICsgZSArIFwiYC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbnIoZSkge1xuICAgICAge1xuICAgICAgICBpZiAoZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIHIgPSBlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sIFwiXCIpLCB0ID0gZS5saW5lTnVtYmVyO1xuICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHlvdXIgY29kZSBhdCBgICsgciArIFwiOlwiICsgdCArIFwiLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgUmUgPSB7fTtcbiAgICBmdW5jdGlvbiBvcihlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0ga2UoKTtcbiAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgdmFyIHQgPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lO1xuICAgICAgICAgIHQgJiYgKHIgPSBgXG5cbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPGAgKyB0ICsgXCI+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX2UoZSwgcikge1xuICAgICAge1xuICAgICAgICBpZiAoIWUuX3N0b3JlIHx8IGUuX3N0b3JlLnZhbGlkYXRlZCB8fCBlLmtleSAhPSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZS5fc3RvcmUudmFsaWRhdGVkID0gITA7XG4gICAgICAgIHZhciB0ID0gb3Iocik7XG4gICAgICAgIGlmIChSZVt0XSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIFJlW3RdID0gITA7XG4gICAgICAgIHZhciBuID0gXCJcIjtcbiAgICAgICAgZSAmJiBlLl9vd25lciAmJiBlLl9vd25lciAhPT0gRy5jdXJyZW50ICYmIChuID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyAkKGUuX293bmVyLnR5cGUpICsgXCIuXCIpLCBOKGUpLCBmKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCB0LCBuKSwgTihudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gRWUoZSwgcikge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChRKGUpKVxuICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgdmFyIG4gPSBlW3RdO1xuICAgICAgICAgICAgcmUobikgJiYgX2Uobiwgcik7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZShlKSlcbiAgICAgICAgICBlLl9zdG9yZSAmJiAoZS5fc3RvcmUudmFsaWRhdGVkID0gITApO1xuICAgICAgICBlbHNlIGlmIChlKSB7XG4gICAgICAgICAgdmFyIHAgPSBEKGUpO1xuICAgICAgICAgIGlmICh0eXBlb2YgcCA9PSBcImZ1bmN0aW9uXCIgJiYgcCAhPT0gZS5lbnRyaWVzKVxuICAgICAgICAgICAgZm9yICh2YXIgdiA9IHAuY2FsbChlKSwgdTsgISh1ID0gdi5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgcmUodS52YWx1ZSkgJiYgX2UodS52YWx1ZSwgcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXIoZSkge1xuICAgICAge1xuICAgICAgICB2YXIgciA9IGUudHlwZTtcbiAgICAgICAgaWYgKHIgPT0gbnVsbCB8fCB0eXBlb2YgciA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGlmICh0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdCA9IHIucHJvcFR5cGVzO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgciA9PSBcIm9iamVjdFwiICYmIChyLiQkdHlwZW9mID09PSBzIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAgICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgICAgIHIuJCR0eXBlb2YgPT09IGEpKVxuICAgICAgICAgIHQgPSByLnByb3BUeXBlcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICB2YXIgbiA9ICQocik7XG4gICAgICAgICAgcWUodCwgZS5wcm9wcywgXCJwcm9wXCIsIG4sIGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHIuUHJvcFR5cGVzICE9PSB2b2lkIDAgJiYgIWVlKSB7XG4gICAgICAgICAgZWUgPSAhMDtcbiAgICAgICAgICB2YXIgcCA9ICQocik7XG4gICAgICAgICAgZihcIkNvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50P1wiLCBwIHx8IFwiVW5rbm93blwiKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlb2Ygci5nZXREZWZhdWx0UHJvcHMgPT0gXCJmdW5jdGlvblwiICYmICFyLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiBmKFwiZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzIGRlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlyKGUpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgciA9IE9iamVjdC5rZXlzKGUucHJvcHMpLCB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICB2YXIgbiA9IHJbdF07XG4gICAgICAgICAgaWYgKG4gIT09IFwiY2hpbGRyZW5cIiAmJiBuICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICBOKGUpLCBmKFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIiwgbiksIE4obnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZS5yZWYgIT09IG51bGwgJiYgKE4oZSksIGYoXCJJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLlwiKSwgTihudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIENlKGUsIHIsIHQsIG4sIHAsIHYpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHUgPSBMZShlKTtcbiAgICAgICAgaWYgKCF1KSB7XG4gICAgICAgICAgdmFyIGMgPSBcIlwiO1xuICAgICAgICAgIChlID09PSB2b2lkIDAgfHwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKGUpLmxlbmd0aCA9PT0gMCkgJiYgKGMgKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiKTtcbiAgICAgICAgICB2YXIgTyA9IG5yKHApO1xuICAgICAgICAgIE8gPyBjICs9IE8gOiBjICs9IGtlKCk7XG4gICAgICAgICAgdmFyIFM7XG4gICAgICAgICAgZSA9PT0gbnVsbCA/IFMgPSBcIm51bGxcIiA6IFEoZSkgPyBTID0gXCJhcnJheVwiIDogZSAhPT0gdm9pZCAwICYmIGUuJCR0eXBlb2YgPT09IG0gPyAoUyA9IFwiPFwiICsgKCQoZS50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCBjID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBTID0gdHlwZW9mIGUsIGYoXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIiwgUywgYyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFIgPSB0cihlLCByLCB0LCBwLCB2KTtcbiAgICAgICAgaWYgKFIgPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gUjtcbiAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICB2YXIgUCA9IHIuY2hpbGRyZW47XG4gICAgICAgICAgaWYgKFAgIT09IHZvaWQgMClcbiAgICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgICBpZiAoUShQKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIEEgPSAwOyBBIDwgUC5sZW5ndGg7IEErKylcbiAgICAgICAgICAgICAgICAgIEVlKFBbQV0sIGUpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShQKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgZihcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIEVlKFAsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlID09PSBiID8gaXIoUikgOiBhcihSKSwgUjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3IoZSwgciwgdCkge1xuICAgICAgcmV0dXJuIENlKGUsIHIsIHQsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbHIoZSwgciwgdCkge1xuICAgICAgcmV0dXJuIENlKGUsIHIsIHQsICExKTtcbiAgICB9XG4gICAgdmFyIHNyID0gbHIsIHVyID0gY3I7XG4gICAgcS5GcmFnbWVudCA9IGIsIHEuanN4ID0gc3IsIHEuanN4cyA9IHVyO1xuICB9KCkpLCBxO1xufVxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbmUuZXhwb3J0cyA9IGRyKCkgOiBuZS5leHBvcnRzID0gbXIoKTtcbnZhciAkZSA9IG5lLmV4cG9ydHM7XG5jb25zdCBnciA9ICh5LCBtLCBfLCBiKSA9PiB7XG4gIGxldCBoID0gbSAvIChfICsgYiksIHcgPSBNYXRoLmZsb29yKHkubGVuZ3RoIC8gaCk7XG4gIGggPiB5Lmxlbmd0aCAmJiAoaCA9IHkubGVuZ3RoLCB3ID0gMSk7XG4gIGNvbnN0IGsgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoOyBpKyspIHtcbiAgICBsZXQgcyA9IDA7XG4gICAgZm9yIChsZXQgZyA9IDA7IGcgPCB3ICYmIGkgKiB3ICsgZyA8IHkubGVuZ3RoOyBnKyspXG4gICAgICBzICs9IHlbaSAqIHcgKyBnXTtcbiAgICBrLnB1c2gocyAvIHcpO1xuICB9XG4gIHJldHVybiBrO1xufSwgdnIgPSAoeSwgbSwgXywgYiwgaCwgdykgPT4ge1xuICBjb25zdCBrID0gbS5oZWlnaHQgLyAyLCBpID0gbS5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGkgJiYgKGkuY2xlYXJSZWN0KDAsIDAsIG0ud2lkdGgsIG0uaGVpZ2h0KSwgaCAhPT0gXCJ0cmFuc3BhcmVudFwiICYmIChpLmZpbGxTdHlsZSA9IGgsIGkuZmlsbFJlY3QoMCwgMCwgbS53aWR0aCwgbS5oZWlnaHQpKSwgeS5mb3JFYWNoKChzLCBnKSA9PiB7XG4gICAgaS5maWxsU3R5bGUgPSB3O1xuICAgIGNvbnN0IG8gPSBnICogKF8gKyBiKSwgYSA9IGsgLSBzIC8gMiwgZCA9IF8sIEUgPSBzIHx8IDE7XG4gICAgaS5iZWdpblBhdGgoKSwgaS5yb3VuZFJlY3QgPyAoaS5yb3VuZFJlY3QobywgYSwgZCwgRSwgNTApLCBpLmZpbGwoKSkgOiBpLmZpbGxSZWN0KG8sIGEsIGQsIEUpO1xuICB9KSk7XG59LCBTciA9ICh7XG4gIG1lZGlhUmVjb3JkZXI6IHksXG4gIHdpZHRoOiBtID0gXCIxMDAlXCIsXG4gIGhlaWdodDogXyA9IFwiMTAwJVwiLFxuICBiYXJXaWR0aDogYiA9IDIsXG4gIGdhcDogaCA9IDEsXG4gIGJhY2tncm91bmRDb2xvcjogdyA9IFwidHJhbnNwYXJlbnRcIixcbiAgYmFyQ29sb3I6IGsgPSBcInJnYigxNjAsIDE5OCwgMjU1KVwiLFxuICBmZnRTaXplOiBpID0gMTAyNCxcbiAgbWF4RGVjaWJlbHM6IHMgPSAtMTAsXG4gIG1pbkRlY2liZWxzOiBnID0gLTkwLFxuICBzbW9vdGhpbmdUaW1lQ29uc3RhbnQ6IG8gPSAwLjRcbn0pID0+IHtcbiAgY29uc3QgW2FdID0gWSgoKSA9PiBuZXcgQXVkaW9Db250ZXh0KCkpLCBbZCwgRV0gPSBZKCksIEMgPSBEZShudWxsKTtcbiAgSCgoKSA9PiB7XG4gICAgaWYgKCF5LnN0cmVhbSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsID0gYS5jcmVhdGVBbmFseXNlcigpO1xuICAgIEUobCksIGwuZmZ0U2l6ZSA9IGksIGwubWluRGVjaWJlbHMgPSBnLCBsLm1heERlY2liZWxzID0gcywgbC5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSBvLCBhLmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHkuc3RyZWFtKS5jb25uZWN0KGwpO1xuICB9LCBbeS5zdHJlYW1dKSwgSCgoKSA9PiB7XG4gICAgZCAmJiB5LnN0YXRlID09PSBcInJlY29yZGluZ1wiICYmIFQoKTtcbiAgfSwgW2QsIHkuc3RhdGVdKTtcbiAgY29uc3QgVCA9IGZyKCgpID0+IHtcbiAgICBpZiAoIWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbCA9IG5ldyBVaW50OEFycmF5KGQgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZnJlcXVlbmN5QmluQ291bnQpO1xuICAgIHkuc3RhdGUgPT09IFwicmVjb3JkaW5nXCIgPyAoZCA9PSBudWxsIHx8IGQuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEobCksIEQobCksIHJlcXVlc3RBbmltYXRpb25GcmFtZShUKSkgOiB5LnN0YXRlID09PSBcInBhdXNlZFwiID8gRChsKSA6IHkuc3RhdGUgPT09IFwiaW5hY3RpdmVcIiAmJiBhLnN0YXRlICE9PSBcImNsb3NlZFwiICYmIGEuY2xvc2UoKTtcbiAgfSwgW2QsIGEuc3RhdGVdKSwgRCA9IChsKSA9PiB7XG4gICAgaWYgKCFDLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZiA9IGdyKFxuICAgICAgbCxcbiAgICAgIEMuY3VycmVudC53aWR0aCxcbiAgICAgIGIsXG4gICAgICBoXG4gICAgKTtcbiAgICB2cihcbiAgICAgIGYsXG4gICAgICBDLmN1cnJlbnQsXG4gICAgICBiLFxuICAgICAgaCxcbiAgICAgIHcsXG4gICAgICBrXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyAkZS5qc3goXG4gICAgXCJjYW52YXNcIixcbiAgICB7XG4gICAgICByZWY6IEMsXG4gICAgICB3aWR0aDogbSxcbiAgICAgIGhlaWdodDogXyxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGFzcGVjdFJhdGlvOiBcInVuc2V0XCJcbiAgICAgIH1cbiAgICB9XG4gICk7XG59LCBociA9ICh5LCBtLCBfLCBiLCBoKSA9PiB7XG4gIGNvbnN0IHcgPSB5LmdldENoYW5uZWxEYXRhKDApLCBrID0gXyAvIChiICsgaCksIGkgPSBNYXRoLmZsb29yKHcubGVuZ3RoIC8gayksIHMgPSBtIC8gMjtcbiAgbGV0IGcgPSBbXSwgbyA9IDA7XG4gIGZvciAobGV0IGEgPSAwOyBhIDwgazsgYSsrKSB7XG4gICAgY29uc3QgZCA9IFtdO1xuICAgIGxldCBFID0gMDtcbiAgICBjb25zdCBDID0gW107XG4gICAgbGV0IFQgPSAwO1xuICAgIGZvciAobGV0IGYgPSAwOyBmIDwgaSAmJiBhICogaSArIGYgPCB5Lmxlbmd0aDsgZisrKSB7XG4gICAgICBjb25zdCBqID0gd1thICogaSArIGZdO1xuICAgICAgaiA8PSAwICYmIChkLnB1c2goaiksIEUrKyksIGogPiAwICYmIChDLnB1c2goaiksIFQrKyk7XG4gICAgfVxuICAgIGNvbnN0IEQgPSBkLnJlZHVjZSgoZiwgaikgPT4gZiArIGosIDApIC8gRSwgbCA9IHsgbWF4OiBDLnJlZHVjZSgoZiwgaikgPT4gZiArIGosIDApIC8gVCwgbWluOiBEIH07XG4gICAgbC5tYXggPiBvICYmIChvID0gbC5tYXgpLCBNYXRoLmFicyhsLm1pbikgPiBvICYmIChvID0gTWF0aC5hYnMobC5taW4pKSwgZy5wdXNoKGwpO1xuICB9XG4gIGlmIChzICogMC44ID4gbyAqIHMpIHtcbiAgICBjb25zdCBhID0gcyAqIDAuOCAvIG87XG4gICAgZyA9IGcubWFwKChkKSA9PiAoe1xuICAgICAgbWF4OiBkLm1heCAqIGEsXG4gICAgICBtaW46IGQubWluICogYVxuICAgIH0pKTtcbiAgfVxuICByZXR1cm4gZztcbn0sIHRlID0gKHksIG0sIF8sIGIsIGgsIHcsIGssIGkgPSAwLCBzID0gMSkgPT4ge1xuICBjb25zdCBnID0gbS5oZWlnaHQgLyAyLCBvID0gbS5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGlmICghbylcbiAgICByZXR1cm47XG4gIG8uY2xlYXJSZWN0KDAsIDAsIG0ud2lkdGgsIG0uaGVpZ2h0KSwgaCAhPT0gXCJ0cmFuc3BhcmVudFwiICYmIChvLmZpbGxTdHlsZSA9IGgsIG8uZmlsbFJlY3QoMCwgMCwgbS53aWR0aCwgbS5oZWlnaHQpKTtcbiAgY29uc3QgYSA9IChpIHx8IDApIC8gcztcbiAgeS5mb3JFYWNoKChkLCBFKSA9PiB7XG4gICAgY29uc3QgQyA9IEUgLyB5Lmxlbmd0aCwgVCA9IGEgPiBDO1xuICAgIG8uZmlsbFN0eWxlID0gVCAmJiBrID8gayA6IHc7XG4gICAgY29uc3QgRCA9IEUgKiAoXyArIGIpLCBsID0gZyArIGQubWluLCBmID0gXywgaiA9IGcgKyBkLm1heCAtIGw7XG4gICAgby5iZWdpblBhdGgoKSwgby5yb3VuZFJlY3QgPyAoby5yb3VuZFJlY3QoRCwgbCwgZiwgaiwgNTApLCBvLmZpbGwoKSkgOiBvLmZpbGxSZWN0KEQsIGwsIGYsIGopO1xuICB9KTtcbn0sIGJyID0gcHIoXG4gICh7XG4gICAgYmxvYjogeSxcbiAgICB3aWR0aDogbSxcbiAgICBoZWlnaHQ6IF8sXG4gICAgYmFyV2lkdGg6IGIgPSAyLFxuICAgIGdhcDogaCA9IDEsXG4gICAgY3VycmVudFRpbWU6IHcsXG4gICAgc3R5bGU6IGssXG4gICAgYmFja2dyb3VuZENvbG9yOiBpID0gXCJ0cmFuc3BhcmVudFwiLFxuICAgIGJhckNvbG9yOiBzID0gXCJyZ2IoMTg0LCAxODQsIDE4NClcIixcbiAgICBiYXJQbGF5ZWRDb2xvcjogZyA9IFwicmdiKDE2MCwgMTk4LCAyNTUpXCJcbiAgfSwgbykgPT4ge1xuICAgIGNvbnN0IGEgPSBEZShudWxsKSwgW2QsIEVdID0gWShbXSksIFtDLCBUXSA9IFkoMCk7XG4gICAgcmV0dXJuIHlyKFxuICAgICAgbyxcbiAgICAgICgpID0+IGEuY3VycmVudCxcbiAgICAgIFtdXG4gICAgKSwgSCgoKSA9PiB7XG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIWEuY3VycmVudClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICgheSkge1xuICAgICAgICAgIGNvbnN0IGwgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKCkgPT4gKHtcbiAgICAgICAgICAgIG1heDogMCxcbiAgICAgICAgICAgIG1pbjogMFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB0ZShcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBhLmN1cnJlbnQsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgaCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAgZ1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEQgPSBhd2FpdCB5LmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGF3YWl0IG5ldyBBdWRpb0NvbnRleHQoKS5kZWNvZGVBdWRpb0RhdGEoRCwgKGwpID0+IHtcbiAgICAgICAgICBpZiAoIWEuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBUKGwuZHVyYXRpb24pO1xuICAgICAgICAgIGNvbnN0IGYgPSBocihcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBfLFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBoXG4gICAgICAgICAgKTtcbiAgICAgICAgICBFKGYpLCB0ZShcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBhLmN1cnJlbnQsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgaCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAgZ1xuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSkoKTtcbiAgICB9LCBbeSwgYS5jdXJyZW50XSksIEgoKCkgPT4ge1xuICAgICAgYS5jdXJyZW50ICYmIHRlKFxuICAgICAgICBkLFxuICAgICAgICBhLmN1cnJlbnQsXG4gICAgICAgIGIsXG4gICAgICAgIGgsXG4gICAgICAgIGksXG4gICAgICAgIHMsXG4gICAgICAgIGcsXG4gICAgICAgIHcsXG4gICAgICAgIENcbiAgICAgICk7XG4gICAgfSwgW3csIENdKSwgLyogQF9fUFVSRV9fICovICRlLmpzeChcbiAgICAgIFwiY2FudmFzXCIsXG4gICAgICB7XG4gICAgICAgIHJlZjogYSxcbiAgICAgICAgd2lkdGg6IG0sXG4gICAgICAgIGhlaWdodDogXyxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAuLi5rXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuYnIuZGlzcGxheU5hbWUgPSBcIkF1ZGlvVmlzdWFsaXplclwiO1xuZXhwb3J0IHtcbiAgYnIgYXMgQXVkaW9WaXN1YWxpemVyLFxuICBTciBhcyBMaXZlQXVkaW9WaXN1YWxpemVyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-audio-voice-recorder/dist/react-audio-visualize.es-69216c73.js\n"));

/***/ })

}]);